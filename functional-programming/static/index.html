<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Functional Programming Presentation</title>

		<meta name="description" content="A presentation on the Functional Programming paradigm">
		<meta name="author" content="Hook">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link href='https://fonts.googleapis.com/css?family=Roboto+Condensed' rel='stylesheet' type='text/css'>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/zenburn.css">
		<link rel="stylesheet" href="css/hook.css">
		<link rel="stylesheet" href="css/index.css">

	</head>

	<body>

		<div class="reveal">

			<!-- hook svg -->
			<a href="http://www.byhook.com" target="_blank" id="logoLink">
				<svg version="1.1" id="logo" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
				   viewBox="0 0 88 131" style="enable-background:new 0 0 88 131;" xml:space="preserve">
				  <g>
				    <g>
				      <path class="logo-fill" d="M63.7,0.1L63.7,0.1C44.3,0.1,44.3,14.9,44.3,24v14.7c0,9.1,0,23.9,19.3,23.9h0C83,62.7,83,47.9,83,38.7V24
				        C83,14.9,83,0.1,63.7,0.1z M68.2,42.2c0,2.2,0,5.7-4.6,5.7s-4.6-3.5-4.6-5.7V20.6c0-2.2,0-5.7,4.6-5.7s4.6,3.5,4.6,5.7V42.2z"/>
				      <path class="logo-fill" d="M24,1.2v21.6c0,0.7-0.5,1.2-1.2,1.2h-6.9c-0.7,0-1.2-0.5-1.2-1.2V1.2c0-0.7-0.5-1.2-1.2-1.2H1.2
				        C0.5,0,0,0.5,0,1.2V24v14.8v22.7c0,0.7,0.5,1.2,1.2,1.2h12.3c0.7,0,1.2-0.5,1.2-1.2V39.9c0-0.7,0.5-1.2,1.2-1.2h6.9
				        c0.7,0,1.2,0.5,1.2,1.2v21.6c0,0.7,0.5,1.2,1.2,1.2h12.3c0.7,0,1.2-0.5,1.2-1.2V38.8V24V1.2c0-0.7-0.5-1.2-1.2-1.2H25.2
				        C24.5,0,24,0.5,24,1.2z"/>
				    </g>
				    <path class="logo-fill" d="M19.3,68.5L19.3,68.5C0,68.5,0,83.2,0,92.4v14.7c0,9.1,0,23.9,19.3,23.9h0c19.3,0,19.3-14.7,19.3-23.9V92.4
				      C38.7,83.2,38.7,68.5,19.3,68.5z M23.9,110.5c0,2.2,0,5.7-4.6,5.7h0c-4.6,0-4.6-3.5-4.6-5.7V88.9c0-2.2,0-5.7,4.6-5.7h0
				      c4.6,0,4.6,3.5,4.6,5.7V110.5z"/>
				    <path class="logo-fill" d="M72.5,131H87c0.8,0,1.3-0.8,0.9-1.5l-15.8-29.3c-0.1-0.3-0.2-0.6,0-0.9l12.5-29.6c0.3-0.7-0.2-1.4-0.9-1.4
				      H69.8c-0.4,0-0.8,0.2-0.9,0.6l-9.2,21.8C59.5,91.1,59,91,59,90.6V69.4c0-0.6-0.5-1-1-1H45.3c-0.6,0-1,0.5-1,1V130c0,0.6,0.5,1,1,1
				      H58c0.6,0,1-0.5,1-1v-21.6c0-0.4,0.5-0.5,0.6-0.2l12,22.3C71.8,130.8,72.1,131,72.5,131z"/>
				  </g>
				</svg>
			</a>

			<div class="slides">
				<!-- INTRO SLIDE -->
				<section>
					<h2>Functional Programming</h2>
					<img src="images/robit.png" alt="Robot picture" class="text-align-center">
					<p>
						<small>Created by <a href="http://byhook.com/" target="_blank">Hook Studios</a></small>
					</p>
				</section>

        <section>
        <h2>Functional Programming</h2>
        <ul>
        <small>
          <li>What is Functional Programming?</li>
          <li>Core Concepts
            <ul>
              <li>First class functions</li>
              <li>Higher-order Functions</li>
              <li>Pure Functions</li>
              <li>Closures</li>
            </ul>
          </li>
          <li>Basic Practies
            <ul>
              <li>Map</li>
              <li>Filter</li>
              <li>Reduce</li>
              <li>Currying</li>
              <li>Functors</li>
              <li>Composition</li>
            </ul>
          </li>
          <li>Lilly Inception Refactor</li>
          <li>Frameworks</li>
          <li>Libraries</li>
          <li>Why bother with Functional Programming?</li>
          <li>Functional Programming vs Object-Oriented</li>
          <li>Conclusion / recap</li>
</small>
        </ul>
        </section>

				<section>
					<h2>What is Functional Programming?</h2>

					<img src="images/refactor.jpg" alt="refactor image">

					<!-- notes -->
					<aside class="notes">
						<small>
							<ul>
								<li>Functional programming is a paradigm where you believe that functions are the most important part of your program.  Data is immutable in functional programming, that is to say that it should never change.  Functional programming operates in a stateless manner, meaning that functions should perform every task as if it was called for the first time, with no knowledge of the future or the past.  In functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function f twice with the same value for an argument x will produce the same result f(x) each time.</li>
								<li><strong>Sidenote:</strong></li>
								<li>This does not mean you don't have objects though! It just means that instead of telling an object to do something, you pass the object to a function, which does something. The important thing to note is that this function does not modify the original object. It might return a modified copy of the object, but the original object is not changed.  Such functions are called pure functions.</li>
							</ul>
						</small>
					</aside>
				</section>
				<!-- CORE CONCEPTS SLIDES/SECTION -->
				<section>

					<section>
						<h2>Functional Programming</h2>
						<h3>Core Concepts</h3>
						<img src="images/core.jpg" alt="Apple Core" style="width: 100%; max-width: 350px;">
					</section>

					<section class="fragments">
            <h4>Core Concepts:</h4>
            <h2>First-Class functions</h2>
						<p> "An entity which supports all the operations generally available to other entities” such as</p>
						<ul>
							<li class="fragment">Being passed as an argument</li>
							<li class="fragment">Being returned from a function</li>
							<li class="fragment">Being assigned to a variable</li>
							<li class="fragment">In other words: An object that also happens to be a function.</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
                  <li>One of the simplest yet most crucial concepts to
                  functional programming.  We don't even need to think about
                  because it's built-in to JavaScript and most popular
                  languages.</li>
									<li>The concept was introduced in the 1960s, as older, imperative languages like Fortran IV and C don’t support array assignment or passage as an argument.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
						<h2>First-Class Functions</h2>
						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
// Function declaration. Okay but can't be nested within non-function blocks
// The whole thing gets hoisted at compile time. (beware)
function double(x) {
	return x * x;
}
							</code>
						</pre>
						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// Function expression, first class! 'var double = undefined' gets hoisted
// but the definition itself does not. (so chill)
var double = function(x) {
	return x * x;
}
							</code>
						</pre>
						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>

// function can be stored in an array, first class!
var myArray = [5, 'socks', {a: 3}, double, false, Nan, []];
							</code>
						</pre>
						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
var nums = [1, 1, 2, 3, 5, 8];

// functon can be passed as an argument, first class!
var sum = nums.map(double); // [1, 1, 4, 9, 25, 64]
							</code>
						</pre>

<!-- notes -->
						<aside class="notes">
                <p>Here are a few examples to illustrate the kinds of behaviors
                that first-class functions enjoy.  If they appear mundane, it's
                probably because they've been supported by popular languages
                for a long time.</p>
						</aside>

</section>
            <section>
								<h2>First class functions are supported by</h3>
								<ul>
									<li>Python</li>
									<li>Go</li>
									<li>Rust</li>
									<li>C#</li>
									<li>Javascript</li>
									<li>All functional languages (Scheme, Haskell, Scala)</li>
									<li>...and many more</li>
								</ul>
						<aside class="notes">
                <p>First Class functions are a necessity for functional
                programming, because without them we couldn’t use higher-order
                functions!</p>
						</aside>


						</section>

					<section class="fragments">
            <h4>Core Concepts:</h4>
            <h2>Higher-Order functions</h2>
						<ul>
							<li class="fragment">Functions that can receive other functions as arguments OR return functions OR both.</li>
							<li class="fragment">Functions that operate on other functions are called higher-order functions.</li>
							<li class="fragment">Higher-order functions can be used to generalize many algorithms that regular functions cannot easily describe.</li>
              <li class="fragment">"Being able to write <i>what</i> we want to
              do instead of <i>how</i> we want to do it means we are working at
              a higher level of abstraction.  In practice this means shorter,
              clearer and more pleasant code." -Marijn Haverbeke, <I>Eloquent
              JavaScript</I></li>
						</ul>

          <aside class="notes">
          <ul>
            <li>(read slides up till third bullet point, then read) "Instead of a messy set of variables and loops you can decompose
          algorithms into a combination of a few fundamental algorithms, which
          are invoked by name and do not have to be typed out again and again.
          Being able to write what we want to do instead of how we do it means
          we are working at a higher level of abstraction.  In practice this
          means shorter, clearer and more pleasant code." -Eloquent Javascript</li>
          </ul>
          </aside>
					</section>

					<section>
						<h2>Higher-Order Functions</h2>
						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
function or(p1, p2) {
	return function(x) {
		return p1(x) || p2(x);
	}
}

function negative(x) {
	return x < 0;
}

function positive(x) {
	return x > 0;
}

var nonzero = or(negative, positive);
console.log(nonzero(-5)); //true
console.log(nonzero(0)); //false
console.log(nonzero(5)); //true
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
                  <li>As an example, let's look at a function that both accepts
                  a function and returns one.  A predicate method.  </li>
									<li>A predicate is a function that takes one item as input
                  and returns either true or false based on whether the item
                  satisfies some condition.  This is great for interrogating objects to learn more about them, or apply operations conditionally to objects.</li>
									<li>Javascript supports passing functions around as values,
                  so we can make <i>predicate combinators</i>:  a fancy term
                  for functions that build new predicates from simpler ones.</li>
									<li>This function consumes two predicates, p1 and p2, and returns a new predicate function.  That predicate tests a value x and returns true if either p1(x) is true or p2(x) is true.</li>
									<li>By using OR we combine NEGATIVE and POSITIVE to get a new function called NONZERO, which returns true if its argument is either negative or positive.</li>
								</ul>
							</small>
						</aside>
					</section>
          <section>
          <h2>Popular higher order functions</h2>
          <ul>
          <li>Map</li>
          <li>Filter</li>
          <li>Reduce</li>
          </ul>
          </section>

					<section>
            <h4>Core Concepts:</h4>
						<h2>Pure functions</h2>
						<img src="images/PureMichigan.jpg" alt="Pure Michigan Image" style="width: 100%; max-width: 200px;">

						<!-- notes -->
						<aside class="notes">
							<p>A function that, given the same input, will always return the same output and does not have any observable side-effects.</p>
						</aside>

					</section>

					<section class="fragments">

						<h2>What's a side effect?</h2>

						<ul>
							<li class="fragment">Changing the file system</li>
							<li class="fragment">Mutating outside variables</li>
							<li class="fragment">Getting user input</li>
							<li class="fragment">Accessing system state</li>
							<li class="fragment">Adding a new variable to a data structure</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>Changing the file system</li>
								<li>Mutating outside variables</li>
								<li>Getting user input</li>
								<li>Accessing system state</li>
								<li>Adding a new variable to a data structure</li>
							</ul>
						</aside>

					</section>

					<section>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
let array = [1, 2, 3, 4, 5];
							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// pure
array.slice(0, 2);
console.log(`[${array}]`); // [1,2,3,4,5]

array.slice(0, 2);
console.log(`[${array}]`); // [1,2,3,4,5]

array.slice(0, 2);
console.log(`[${array}]`); // [1,2,3,4,5]
							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// impure
array.splice(0, 2);
console.log(`[${array}]`); // [3,4,5]

array.splice(0, 2);
console.log(`[${array}]`); // [5]

array.splice(0, 2);
console.log(`[${array}]`); // []

							</code>
						</pre>
					</section>

					<section>

						<img src="images/pulp.png" alt="Pulp Fiction reference">

						<!-- notes -->
						<aside class="notes">
							<p>Lastly, it’s important to mention immutable state.  That is to say - the state cannot change.  In multi-threaded applications, this is a great thing.  It allows the thread to act on data without worrying what other threads are up to.</p>
						</aside>

					</section>

					<section class="fragments">
            <h4>Core Concepts:</h4>
						<h2>Closures</h2>
						<p><strong>Closure</strong>: A loveable concept</p>
						<ul>
							<li class="fragment">Only accessible to a specific returning function.</li>
							<li class="fragment">Place nicely with pure functions.</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<p>Closure.  We all love and know it already, but just to overview:</p>

							<ul>
								<li>Data saved inside a function that is only accessible to a specific returning function.</li>
								<li>This of course plays nicely with pure functions as we only mutate internal variables in a functional approach.</li>
							</ul>
						</aside>

					</section>

					<section class="fragments">
						<h2>Closures</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
let add = function(a){
  return function(b){
    return a + b;
  }
};
							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// the variable 'a' is enclosed and
// is only accessible to the returning function.

let add10 = add(10);
let result = add10(20);

console.log(result);
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<p>Closures have three scope chains:  It has access to its own scope, the outer function’s variables and of course global variables - but we don’t use global variables in functional programming.</li>
							</p>
						</aside>

					</section>

				</section>

					</section>
				<!-- BASICS SLIDES/SECTION -->
				<section>
					<section>
						<h2>Functional Programming</h2>
						<h3>Basics Practices</h3>
						<img src="images/functions-in-out.png" alt="Functional Programming diagram" style="width: 100%; max-width: 300px; height: auto;">

						</section>
					<section>
            <h4>The Basics</h4>
						<h2>map()</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
let array = [0, 1, 2, 3, 4, 5];

// a basic map function
array.map((element, index) => {
  console.log(`Element: ${element} <br/>`);
  console.log(`Index: ${index} <br/>`);
});

// for loop comparison
for(let i = 0; i < array.length; i++) {
  console.log(`Element: ${array[i]} <br/>`);
  console.log(`Index: ${i} <br/>`);
};

// index is optional!
// a basic map function
array.map((element) => {
  console.log(`Element: ${element} <br/>`);
});

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Map… I think we’re all pretty familiar with the function, specifically because we just used it in our previous example, that said - it never hurts to recap.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section>
						<h4>The Basics</h4>
						<h2>map()</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
const map = (fn, value) => value.map(fn);
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Now let’s talk about how map applies to functional programming.</li>
									<li>Map takes a function and a functor and applies the function to each of the functor’s values and returns a functor of the same shape.</li>
									<li>The Verdict? Map is awesome and is a tool you’ll find yourself using very often.</li>
								</ul>
							</small>
						</aside>
					</section>

          <section>
            <h4>The Basics</h4>
						<h2>filter()</h2>
<p><strong>Array.filter()</strong> calls a provided callback once for each
element in the array and constructs a new array of all the values for which the
callback returns ‘true’ or a value that coerces to true.  Only invoked for
indexes which have assigned values.
</p>
          </section>

          <section> 
          <h2>Filter()</h2>
						<pre class="custom-pre">
							<code class="hljs" data-trim>
var customers = [
  {
    name: 'John',
    phone: '(877)4432-12'
  }, 
  {
    name: 'Anne',
    phone: '323-847-1590'
  },
  {
    name: 'Daphne',
    phone: '+1 23 5461'
  },
  {
    name: 'Howard',
    phone: '13607034562'
  }
]
          </code>
        </pre>
          <aside class="notes">
          <p>Example: Suppose we have some data, like a JSON api response that
          contains customers.  We want to filter out the customers with a valid
          phone number so we can create a list of customers we can actually
          reach.</p>
          </aside>
          </section>

					<section class="fragments">
            <h5>Filter()</h5>
						<pre class="custom-pre ">
							<code class="hljs" data-trim contenteditable>
var reachable = function() {
  var valid = [];
    vor(var i = 0; i < customers.length; i++) {
      var sanitizedPhone = customers[i].phone.replace(/\D/g, '');
      if(sanitizedPhone.length === 10 || sanitizedPhone.length === 11) {
        valid.push(customers[i]);
        }
      }
      return valid;
};
							</code>
						</pre>
            <pre class="custom-pre ">
							<code class="hljs" data-trim contenteditable>
var reachable = customers.filter(function(person) {
  var sanitizedPhone = person.phone.slice().replace(/\D/g, '');
  return sanitizedPhone.length === 10 || sanitizedPhone.length === 11;
});
							</code>
						</pre>
            <pre class="custom-pre ">
							<code class="hljs" data-trim contenteditable>
var hasValidPhoneNumber = function(person) {
  var sanitizedPhone = person.phone.slice().replace(/\D/g, '');
  return sanitizedPhone.length === 10 || sanitizedPhone.length === 11;
}

var reachable = customers.filter(hasValidPhoneNumber);
							</code>
						</pre>




						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
<li>(note to self: talk through the functions line by line)</li>
<li>Verbose, one-time-use-only, impure, imperative (aka bad!) way:</li>
<li>Better, uses filter with an anonymous callback function</li>
<li>Best! Uses filter with a first-class callback function.  The callback
'hasValidPhoneNumber' slots directly into filter, which is what makes
higher-order functions composable.</li>
<li>If we wanted to abstract 'reachable' into a function that accepts any
object of data and filters for valid phone numbers, reuse is even easier!</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">

            <h4>The Basics</h4>
						<h2>reduce()</h2>
						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
arr.reduce(callback [, initialValue]);

							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
var numbers = [1,2,3,4];

// sum up all the values of an array
numbers.reduce(function(x,y) {
  return x+y
}, 0); // 10

// es6
numbers.reduce ((x, y) => x + y); // 10

// find the largest number
numbers.reduce((x, y) => Math.max(x, y), 0); // 4

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Sometimes called fold</li>
									<li>function is used to accumulate all the values of the array into one</li>
									<li>callback needs to return the logic to be performed to combine the objects</li>
									<li><strong>Numbers: </strong>usually added together to get a sum or multiplied together to get a product</li>
									<li><strong>Strings: </strong>often appended together</li>
								</ul>
							</small>
						</aside>
					</section>

					<!-- <section>

            			<h4>The Basics</h4>
						<h2>reduce()</h2>
						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
var numbers = [1,2,3,4];

numbers.reduce( (newArray, number) => {
   newArray.push(number);
  
  if(number % 2 === 0) {
    // if even number, add it a second time
    newArray.push(number);
  }
  
  return newArray
  
}, []); // [1, 2, 2, 3, 4, 4]

							</code>
						</pre>

						<aside class="notes">
							<small>
								<ul>
									<li>Note how we start out with [] as initial value, and just add the value to it one or more times.</li>
									<li>technically, violates the "no mutation" rule, it's okay in this particular situation</li>
									<li>the array object is created explicitly for this reduce call, so it can't cause side-effects anywhere else in the code</li>
								</ul>
							</small>
						</aside>
					</section> -->


					<section>
						<p>Have you heard of Ramda or currying?</p>

            <img src="images/goku.gif" alt="Goku eating some curry">

						<p>Not quite....</p>

					</section>

					<section>
						<h4>The Basics</h4>
						<h2>Currying</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
// normal - regular addition
let add = (a, b) => a + b;

// let add = function(a, b) {
//   return a + b;
// };

console.log(`Normal JS Invocation: ${add(1, 2)}`); // 3
console.log(`Normal JS Invocation: ${add(1, 2, 'IGNORE ME')}`); // 3
console.log(`Normal JS Invocation: ${add(1)}`); // NaN

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>The concept is simple: You can call a function with fewer arguments than it expects. It returns a function that takes the remaining arguments.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section>
						<h2>Currying</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
// curried - curried addition
// a curried function is one where multiple arguemnts are described by a
// series of one-argument functions.
let addCurried = a => b => a + b;

// let addCurried = function(a) {
//   return function(b) {
//     return a + b;
//   };
// };

let cAdd = addCurried(1);

console.log(`Curried: ${cAdd(2)}`); // 3
console.log(`Curried: ${cAdd(2, 'IGNORE ME')}`); // 3

// ramda - makes stuff easier
let ramdaCurried = R.curry(add);

let rAdd = ramdaCurried(1);

console.log(`Curried: ${rAdd(2)}`); // 3
console.log(`Curried: ${rAdd(2, 'IGNORE ME')}`); // 3
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<p>Thankfully the Ramda library makes currying things much easier.</p>
							</small>
						</aside>

					</section>

					<section class="fragments">
						<h2>Currying</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
let objects = [{ id: 1 }, { id: 2 }, { id: 3 }];

console.log(`w/o Curry: [${objects.map(o => o.id)}]`); // [1, 2, 3]

let get = R.curry((property, object) => {
  return object[property];
});

console.log(`w/ Curry: [${objects.map(get('id'))}]`); // [1, 2, 3]
							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// Take it even further!
let map = R.curry((fn, value) => value.map(fn));

let getIDS = map(get('id'));

console.log(`Super Ultra Functional: [${getIDS(objects)}]`); // [1, 2, 3]
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Currying has it’s advantages, let’s say we wanted to map over an array of objects to get an id.  Easy enough, but if we apply curry and make a get function, we can get a bit cleaner.</li>
									<li>Even further, we can actually rewrite the map function to accept another function and map that value.  Leaving us with some super clean code no doubt.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section>

						<img src="images/arrow-functions.jpg" alt="Arrow Functions">

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Is it really necessary though?  Even in the examples provided, I’m using ES6 and we all know arrow functions greatly reduce visual noise and make code look pretty already.  Supplying a curried function with too few arguments is an easy mistake to make and it can often only cause an error at a much later stage in code.  Embedded in a complex codebase of many of the applications and websites we build - it can be easy to waste a handful of hours searching for the origins of a mysterious function.</li>
									<li>Is it actually necessary to curry everything?  The answer is no - probably not.  Can it impede a programmer's ability in real world practice?  That’s up for debate, regardless - I think most are in agreement that arrow functions work great and solve most of the problems that currying solves.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section>
    				<h4>The Basics</h4>
						<h2>Functors</h2>

						<img src="images/funk.jpg" alt="We want the funk">
						<p>Not to be confused with funk-sters</p>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Term "Functor" comes from Category Theory, a mathmatical concept</li>
									<li>I won't begin to try and explain it's place in math, but as far as computer programming goes, let’s just say that category theory is simply "connecting the dots".</li>
									<li>Some quick terminolgy</li>
									<li><strong>Catgories</strong> are just sets with the same type. In JavaScript, they're arrays or objects that contain variables that are explicitly declared as numbers, strings, Booleans, dates, nodes, and so on.</li>
									<li><strong>Morphisms </strong>are pure functions that, when given a specific set of inputs, always return the same output.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
						<h2>Functors</h2>
						<ul>
							<li class="fragment">Functors map between categories.</li>
							<li class="fragment">They can be thought of as functions that lift values out of a container, morph them, and then put them into a new container.</li>
							<li class="fragment">The first input is a morphism for the type and the second input is the container.</li>
						</ul>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// Note that the type signature for functors looks like so

// my functor :: (a -> b) -> f a -> f b

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>This says, "give me a function that takes a and returns b and a box that contains a(s), and I'll return a box that contains b(s).</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
						<h2>Functors</h2>
						<p class="text-align-left">We already have one functor: map(). It grabs the values within the container, an array, and applies a function to it.</p>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
var nums = [1, 4, 9];

nums.map(Math.sqrt); // [1, 2, 3]

							</code>
						</pre>

						<small><p class="fragment">However, we'll need to write it as a global function and not as a method of the array.  This allows us to write cleaner, safter code later on.</p></small>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// map :: (a -> b) -> [a] -> [b]
var map = function(f, a) {
	return arr(a).map(func(f));
}

							</code>
						</pre>
					</section>



					<section class="fragments">
						<h4>The Basics</h4>
						<h2>Composition</h2>
						<ul>
              <li class="fragment"><strong>Function Composition: </strong>The
              combination of simple functions to build more sophisticated
              ones.</li>
              <li class="fragment"> Composing functions allows us to build complex functions from many simple, generic functions.</li>
							<li class="fragment">By treating functions as building blocks for other functions, we can build truly modular applications with excellent readability and maintainability.</li>
						</ul>
            <aside class="notes">
<p> Types of things we might want to compose: multi-step processes with stages
that also occur in other multi-step processes - stages we might want to
recreate later."</p>
						</aside>

					</section>

					<section class="fragments">
						<h2>Composition</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
// function that combines two functions together:
// run function 'f' on the result of function 'g'
var compose = function(f, g) {
  return function(x) {
	  return f(g(x));
  };
};

// ES6 hyper-terse equivalent
const compose = (f, g) => (x) => f(g(x));

const upperCase = (str) => str.toUpperCase();
const trim = (str) => str.replace(/^\s+I\s+$/g, '');
const replaceIWithBang = (str) => str.replace(/[i]/g, '!');

const labelMaker = compose(upperCase, trim);
// Ramda's built-in compose method takes any number of functions and
// will return them right-to-left
const coolLabelMaker = R.compose(upperCase, replaceIWithBang, trim);

let labels = [' iconic ', 'high five    ', ' bim bap'].map(labelMaker);
let coolLabels = [' iconic ', 'high five    ', ' bim bap'].map(coolLabelMaker);

console.log(labels); // [ 'ICONIC', 'HIGH FIVE', 'BIM BAP']
console.log(coolLabels); // ["!CON!C", "H!GH F!VE", "B!M BAP"]

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
<li>Example: make a "label maker" function composed of "trim" and
"upperCase".</li>
									<li>Thank heavens Ramda has a method, R.compose so we don’t have to write our own (gets pretty gnarly when writing a custom compose function that takes more than two functions).</li>
								</ul>
							</small>
						</aside>
          </section>

          <section class="fragments">
          <h2>Composing in the wild</h2>
          <p>Generating a valid HTTP request using an oauth signature</p>
          <ul>
            <li>request method (GET or POST)</li>
            <li>base url ('https://api.twitter.com/1/statuses/update.json')</li>
            <li>request parameters (status="Best tacos")</li>
            <li>oauth parameters (consumer key, method, timestamp, token, oauth
            version)
              <ul>
                <li>Percent encode every key and value that will be signed</li>
                <li>Sort the list of parameters alphabetically by encoded
                key</li>
                <li>For each key/value pair:
                  <ul>
                  <li> append encoded key to the output
                  string</li>
                  <li>Append the '=' character to the output string.</li>
                  <li>If there are any key/value pairs remaining, append the '&'
                  character to the output string.</li>
                  </ul>
              </ul>
            </li>
          </ul>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
<li>Using Yelp or Twitter's API necessitates generating a valid HTTP request
with an oauth signature.  There are many libraries out there for this.</li>
									<li>Thank heavens Ramda has a method, R.compose so we don’t have to write our own (gets pretty gnarly when writing a custom compose function that takes more than two functions).</li>
								</ul>
							</small>
						</aside>
              </section>

				</section>

				<!-- LILLY INCEPTION REFACTOR SLIDES/SECTION -->
				<section>
					<section>
						<h2>Functional Programming</h2>
						<h3>Lilly Inception Refactor</h3>
						<img src="images/mkay.jpg" alt="Im gonna need those TPS reports Thanks">
					</section>

					<section>
						<h3>Canvas.js - original version</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

var createjs = require('createjs');

var canvas;
var stage;
var exportRoot;

// set canvas id
var Canvas = function() {
  canvas = document.getElementById('you-line');
};

// initialize canvas animation
Canvas.prototype.init = function() {
  exportRoot = new lib02.Youtube_Beacon05_Lily_970x250();
  stage = new createjs.Stage(canvas);
  stage.addChild(exportRoot);
  stage.update();
  stage.enableDOMEvents(false);
};

// start canvas animation
Canvas.prototype.start = function() {
  canvas.style.opacity = 1;
  createjs.Ticker.setFPS(lib02.properties.fps);
  createjs.Ticker.addEventListener('tick', stage);
};

module.exports = Canvas; //29 lines
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>OOP Constructor Function</li>
							</ul>
						</aside>

					</section>

					<section>

						<h3>Canvas.js - refactored</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

import createjs from 'createjs';

export default function() {
  const youLine = document.getElementById('you-line');
  const exportRoot = new lib02.Youtube_Beacon05_Lily_970x250();
  const stage = new createjs.Stage(youLine);
  const canvas = Object.create({});

  canvas.init = () => {
    stage.addChild(exportRoot);
    stage.update();
    stage.enableDOMEvents(false);
  };

  canvas.start = () => {
    youLine.style.opacity = 1;
    createjs.Ticker.setFPS(lib02.properties.fps);
    createjs.Ticker.addEventListener('tick', stage);
  };

  return canvas;
}; //23 lines - 20% reduction

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>canvas = Object.create({});</li>
								<li>start() and init() are now arrow functions</li>
                <li>20% reduction of code</li>
							</ul>
						</aside>

					</section>

					<section>

						<h3>Loader.js - original version</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

function Loader( manifest ) {
  this.manifest = manifest;
  this.loadItems = 0;
  this.loadItemsTotal = 0;
  this.loadComplete = false;
  this.consoleObject = {
    loaded: 0.0
  };

  manifest.forEach(function(item) {
    this._loadImage(item.src);
  }.bind(this));

  this._loadScript('js/vendor.js');
}

Loader.prototype._loadImage = function( path ) {
  this.consoleObject[path] = false;
  var img = new Image();
  img.addEventListener( 'load', this._onLoad.bind( this, path ) );
  img.src = path;
  this.loadItemsTotal++;
};

Loader.prototype._loadScript = function( path ) {
  this.consoleObject[path] = false;
  global.Enabler.loadScript( global.Enabler.getUrl( path ), this._onLoad.bind( this, path ) );
  this.loadItemsTotal++;
};

Loader.prototype._onLoad = function ( id ) {
  this.loadItems++;
  this.consoleObject[id] = true;
  this.consoleObject.loaded = Math.round( ( this.loadItems / this.loadItemsTotal ) * 100 ) + '%';
  if ( this.loadItemsTotal === this.loadItems ) {
    this._onLoadComplete();
  }
};

Loader.prototype._onLoadComplete = function () {
  if (this.loadComplete === true) {
    return;
  }

  this.loadComplete = true;
  this._loadScript('js/main.build.js');
};

module.exports = Loader; //50 lines of code
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>OOP Constructor Function</li>
							</ul>
						</aside>
					</section>

					<section>

						<h3>Loader.js - refactored</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

export default function(manifest) {

  //Loads all the images in the manifest
  const loadImage = function(path) {
    return new Promise((resolve, reject) => {
      let img = new Image();
      img.addEventListener('load', resolve);
      img.addEventListener('error', reject);
      img.src = path.src;
    });
  };

  //loads vendor and main.build scripts, individually
  const loadScript = function(path) {
    return new Promise((resolve, reject) => {
      global.Enabler.loadScript(global.Enabler.getUrl(path), resolve);
    });
  };

  const loadImagePromise = manifest.map(loadImage);
  const loadVendor =  loadScript('js/vendor.js');
  const loadMain = () => loadScript('js/main.build.js');

  //After all the images have loaded, then load in vendor, lastly load mainbuild.js
  Promise.all(loadImagePromise.concat(loadVendor)).then(loadMain);
}; //24 lines of code - 52% reduction.


							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>using Promises</li>
                <li>52% reduction of code</li>
							</ul>
						</aside>
					</section>

					<section>

						<h3>Load.js - original</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>

'use strict';

var config = require('../config');
var Loader = require('./Loader');

// set up youtube iframe api, add function to global scope
var Bootstrap = function () {

  this.tag = document.createElement('script');
  this.tag.src = 'https://www.youtube.com/iframe_api';
  this.firstScriptTag = document.getElementsByTagName('script')[0];
  this.firstScriptTag.parentNode.insertBefore(this.tag, this.firstScriptTag);

  window.onYouTubeIframeAPIReady = function() {
    this.onYouTubeLoaded();
  }.bind(this);

};

// once youtube is loaded, initialize enabler
Bootstrap.prototype.onYouTubeLoaded = function () {

  if (Enabler.isInitialized()) {
    this.onInitialize();
  } else {
    Enabler.addEventListener(studio.events.StudioEvent.INIT, this.onInitialize.bind(this));
  }

};

// once the page is initialized, check that the page is loaded and fire pageLoadedHandler
Bootstrap.prototype.onInitialize = function () {

  if (Enabler.isPageLoaded()) {
    this.pageLoadedHandler();
  } else {
    Enabler.addEventListener(studio.events.StudioEvent.PAGE_LOADED, this.pageLoadedHandler.bind(this));
  }

};

// make ad visible
Bootstrap.prototype.pageLoadedHandler = function () {

  if (Enabler.isVisible()) {
    this.adVisibleHandler();
  } else {
    Enabler.addEventListener(studio.events.StudioEvent.VISIBLE, this.adVisibleHandler.bind(this));
  }

};

// create ad
Bootstrap.prototype.adVisibleHandler = function () {

  var loader = new Loader(config.manifest);

};

module.exports = Load; //59 lines of code
							</code>
						</pre>

					</section>

					<section>

						<h3>Load.js - refactored</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

import { config } from './config';
import Loader from './core/Loader';

// Load the YouTube API, insert the script tag and assign the window object.
const loadYTApi = () => {

  const tag = document.createElement('script');
  tag.src = 'https://www.youtube.com/iframe_api';
  const firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

  return new Promise( (resolve, reject) => {
    window.onYouTubeIframeAPIReady = resolve;
  });

};

// Returns a promise that resolves if the method is true, otherwise assigns an event listener.
const enablerCheck = (method, state) => {

  return new Promise( (resolve, reject) => {
    return method() ? resolve() : Enabler.addEventListener(state, resolve);
  });

};

// Load the manifest once the Ad is visible.
const adVisibleHandler = () => {
  const loader = Loader(config.manifest);
};

// Enabler promises for initialize, load and visible states.
const initPromise = enablerCheck(Enabler.isInitialized.bind(Enabler), studio.events.StudioEvent.INIT);
const loadPromise = enablerCheck(Enabler.isPageLoaded.bind(Enabler), studio.events.StudioEvent.PAGE_LOADED);
const visiblePromise = enablerCheck(Enabler.isVisible.bind(Enabler), studio.events.StudioEvent.VISIBLE);

// If everything is a-ok, show the Ad.
Promise.all([loadYTApi(), initPromise, loadPromise, visiblePromise]).then(adVisibleHandler);
//39 lines of code - 34% reduction of code

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>enablerCheck(): returns a promise</li>
                <li>34% reduction of code</li>
							</ul>
						</aside>

					</section>

					<section>

						<h3>Animation.js - original version</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

var TweenMax = require('TweenMax');

var AnimationController = function () {

  // selectors
  this.player = document.querySelector('#player');
  this.animationWrap = document.querySelector('#animation');
  this.loader = document.querySelector('#loading');
  this.whiteBox = document.querySelector('#white-box');
  this.lillyText = document.querySelector('#lilly-text');
  this.fansText = document.querySelector('#fans-text');
  this.slash = document.querySelector('#slash');
  this.underlay = document.querySelector('#underlay');
  this.lozenge = document.querySelector('#lozenge');

  // booleans
  this.endOnce = true;

  this.init();

};

// initialize controller, build all timelines.
AnimationController.prototype.init = function() {
  this.globalTimeline = new TimelineMax({paused: true});
  this.globalTimeline.add(this.tl1(), 0.0);
  this.globalTimeline.add(this.tl2(), 21.25);
  return this.globalTimeline;
};

// timeline 0 - loading  wipe animation
AnimationController.prototype.tl1 = function () {
  this.tl1 = new TimelineMax();
  this.tl1.to([this.underlay, this.loader], 0.4, {autoAlpha: 0, ease: Power1.easeOut});
  return this.tl1;
};

// timeline 4 - last zoom in of branding
AnimationController.prototype.tl2 = function () {
  this.tl2 = new TimelineMax();
  this.tl2.fromTo(this.animationWrap, 3.225, {x: '-200%',
    autoAlpha: 1,
    scaleX: 10,
    scaleY: 10},
    {x: '0%',
    scaleX: 1,
    scaleY: 1,
    ease: Power3.easeOut});

  return this.tl2;
};

// make player visible, set animation wrap and fire tl0
AnimationController.prototype.start = function () {
  this.player.style.opacity = 1;
  this.globalTimeline.play();
};

// play animation
AnimationController.prototype.play = function () {
  this.globalTimeline.play();
};

// seek animation
AnimationController.prototype.seek = function(time) {
  this.globalTimeline.seek(time);
};

// pause animation
AnimationController.prototype.pause = function () {
  this.globalTimeline.pause();
};

// kill all animations, end banner
AnimationController.prototype.endState = function () {
  if (this.endOnce) {
    TweenMax.killAll(true, true, true, true);
    TweenMax.set(this.animationWrap, {autoAlpha: 1});
    this.endOnce = false;
  }
};

module.exports = AnimationController; //84 lines of code
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>OOP Constructor Function</li>
							</ul>
						</aside>

					</section>

					<section>

						<h3>Animation.js - refactored</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

import TweenMax from 'TweenMax';

export default function() {
    // selectors
    const player = document.querySelector('#player');
    const animationWrap = document.querySelector('#animation');
    const loader = document.querySelector('#loading');
    const whiteBox = document.querySelector('#white-box');
    const lillyText = document.querySelector('#lilly-text');
    const fansText = document.querySelector('#fans-text');
    const slash = document.querySelector('#slash');
    const underlay = document.querySelector('#underlay');
    const lozenge = document.querySelector('#lozenge');

    // timeline
    let timeline = null;

    // booleans
    let endOnce = true;

    const animation = Object.create({});

    animation.init = () => {
      timeline = new TimelineMax({paused: true});
      timeline.add(fadeOutLoader(), 0.0);
      timeline.add(animateBranding(), 21.25);
      return timeline;
    };

    function fadeOutLoader() {
      const tl = new TimelineMax();
      tl.to([underlay, loader], 0.4, {autoAlpha: 0, ease: Power1.easeOut});
      return tl;
    };

    function animateBranding() {
      const tl = new TimelineMax();
      tl.fromTo(animationWrap, 3.225, {x: '-200%',
        autoAlpha: 1,
        scaleX: 10,
        scaleY: 10},
        {x: '0%',
        scaleX: 1,
        scaleY: 1,
        ease: Power3.easeOut});
      return tl;
    };

    animation.start = () => {
      player.style.opacity = 1;
      timeline.play();
    };

    animation.play = () => timeline.play();

    animation.seek = (time) => timeline.seek(time);

    animation.pause = () => timeline.pause();

    animation.endState = () => {
      if (endOnce) {
        TweenMax.killAll(true, true, true, true);
        TweenMax.set(animationWrap, {autoAlpha: 1});
        endOnce = false;
      }
    };

    return animation;
}; //70 lines of code - 16% reduction


							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>Use of ES6 import and export</li>
								<li>animation = Object.create({});</li>
								<li>play(), seek(), and init() are now arrow functions</li>
                <li>16% reduction in size from original</li>
							</ul>
						</aside>

					</section>

				</section>

				<!-- FRAMEWORK SLIDES/SECTION -->
				<section>

					<section>
						<h2>Functional Programming</h2>
						<p>Let's talk Frameworks</p>
						<img src="images/frameworks.png" alt="different js framework logos">
					</section>

					<section class="fragments">

						<h2>Functional Progamming</h2>
						<p>React</p>
						<img src="images/react.png" alt="React.js logo" class="text-align-center">
						<br>
						<ul>
							<li class="fragment">Components provide abstractions</li>
							<li class="fragment">Composable Functions</li>
							<li class="fragment">Virtual DOM</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li><strong>React</strong>'s authors define it as a JavaScript library for creating UIs and addressing problem of building large applications with data that changes over time.  React brings the very basic essence of functional programming to the table. It provides abstractions such as components which are basically (pure) functions and get you away from imperatively touching the DOM.</li>
									<li>In terms of functional programming, you write composable functions. Data is coming to your functions as input which emit tree like representations as return values. When data changes, functions are re-run again with new data as input. React diffs the result of previous function call with new one and it effectively calculates the difference between the tree structures. From higher level perspective, React is a function which takes two DOMs and generates a list of DOM operations to be applied to the DOM.</li>
									<li>React’s rendering leverages the Virtual DOM - an in-memory representation of what the actual DOM should look like. When the state changes, React does a full re-render of the Virtual DOM, diffs it, and then patches the real DOM.</li>
								</ul>
							</small>
						</aside>

					</section>

					<section>
						<h3>React</h3>

						<pre>
							<code class="hljs" data-trim contenteditable>
var Timer = React.createClass({
  getInitialState: function() {
    return {secondsElapsed: 0};
  },

  tick: function() {
    this.setState({secondsElapsed: this.state.secondsElapsed + 1});
  },

  componentDidMount: function() {
    this.interval = setInterval(this.tick, 1000);
  },

  componentWillUnmount: function() {
    clearInterval(this.interval);
  },
  
  render: function() {
    return (
      <div>Seconds Elapsed: {this.state.secondsElapsed}</div>
    );
  }
});
ReactDOM.render(&lt;Timer /&gt;, mountNode);
					
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>This is example of stateful component</li>
								<li>To allow reuse of components each of the components has its own unique state accessed via this.state</li>
								<li>When using stateful components, initial state is defined through getInitialState method</li>
								<li>In order to keep up with FP principles and get advantage out of them, this function should be pure in general i.e. should not depend on anything other than component state &amp; properties and generate any side effects.</li>
							</ul>
						</aside>

					</section>

					<section class="fragments">

						<h2>Functional Progamming</h2>
						<p>Deku</p>
						<img src="images/deku.png" alt="Deku.js logo" style="width: 100%; max-width: 250px;">
						<br>
						<ul>
							<li class="fragment">"Functional alternative to React"</li>
							<li class="fragment">Define your UI as a tree of components</li>
							<li class="fragment">Virtual DOM</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li><strong>Deku:</strong> Deku is a library for rendering interfaces using pure functions and virtual DOM.  It's the self proclaimed "functional alternative to React"
									<li>With Deku, you define your UI as a tree of components and whenever a state change occurs, it re-renders the entire tree to patch the DOM using a highly optimized diffing algorithm.
									</li>Instead of using classes and local state, Deku just uses functions and pushes the responsibility of all state management and side-effects onto tools like Redux. It also aims to support only modern browsers to keep things simple.</li>
								</ul>
							</small>
						</aside>

					</section>

					<section class="fragments">
						<h3>Deku</h3>

						<pre>
							<code class="hljs" data-trim contenteditable>
import {element} from 'deku'

function render (component) {
  let {props,state} = component
  return <button type={props.type}>{props.children}</button>
}

function afterMount(component, el, setState) {
  setState({ mounted: true })
}

export default { render, afterMount }
					
							</code>
						</pre>

						<pre class="fragment">
							<code class="hljs" data-trim contenteditable>
import {tree,render,element} from 'deku'
import Button from './button'

var app = tree(<Button>Hello World</Button>)
render(app, document.body)
					
							</code>
						</pre>

						<pre class="fragment">
							<code class="hljs" data-trim contenteditable>
export let Button = {
  render({props, state}) {
    return <button>{props.text}</button>
  }
}
					
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>Here's what a component looks like in Deku</li>
								<li>imort components and render your app</li>
								<li>You’ll notice there is no concept of classes or use of this</li>
								<li>We’re using plain objects and functions</li>
								<li>The beauty of using plain functions is that the user can use the ES6 module system to define them however they want</li>
							</ul>
						</aside>

					</section>

					<section class="fragments">

						<h2>Functional Progamming</h2>
						<p>Vue</p>
						<img src="images/vue.jpg" alt="Vue.js logo" style="width: 100%; max-width: 300px;">
						<br>
						<ul>
							<li class="fragment">Provides reactive and composable View components</li>
							<li class="fragment">Uses the actual DOM as the template</li>
							<li class="fragment">Limited to environments where DOM is present</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li><strong>Vue: </strong>Vue.js, like React, provides reactive and composable View components.</li>
									<li>Vue.js itself is not a full-blown framework - it is focused on the view layer only.</li>
									<li>Instead of a Virtual DOM, Vue.js uses the actual DOM as the template and keeps references to actual nodes for data bindings. This limits Vue.js to environments where DOM is present. However, contrary to the common misconception that Virtual-DOM makes React faster than anything else, Vue.js actually out-performs React when it comes to hot updates, and requires almost no hand-tuned optimization.</li>
								</ul>
							</small>
						</aside>

					</section>

					<section>
						<h3>Vue</h3>

						<pre style="top: -10px;">
							<code class="hljs" data-trim contenteditable>
<div id="app">
  <input v-model="newTodo" v-on:keyup.enter="addTodo">
  <ul>
    <li v-for="todo in todos">
      <span>{{ todo.text }}</span>
      <button v-on:click="removeTodo($index)">X</button>
    </li>
  </ul>
</div>				
							</code>
						</pre>

						<pre style="top: -65px;">
							<code class="hljs" data-trim contenteditable>
new Vue({
  el: '#app',
  data: {
    newTodo: '',
    todos: [
      { text: 'Add some todos' }
    ]
  },
  methods: {
    addTodo: function () {
      var text = this.newTodo.trim()
      if (text) {
        this.todos.push({ text: text })
        this.newTodo = ''
      }
    },
    removeTodo: function (index) {
      this.todos.splice(index, 1)
    }
  }
})
					
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>still working with objects</li>
								<li>functional methods</li>
							</ul>
						</aside>

					</section>

				</section>

				<!-- LIBRARIES SLIDE/SECTION -->
				<section>
					<section>
						<h2>Functional Programming</h2>
						<h3>Let's talk Libraries</h3>
						<img src="images/library.gif" alt="At the library like">
					</section>

					<section class="fragments">
						<h2>Functional Programming</h2>
						<p>Let's talk Libraries</p>
						<p class="text-align-left">As the years go, Internet Explorer 9 has faded into the past and native ES5 methods are expected for most applications. So the role of functional programming libraries has shifted from a compatibility layer to adding new, foundational methods for functional programming.</p>

					</section>

					<section class="fragments">
						<h2>Functional Programming</h2>
						<p>Underscore</p>
						<img src="images/underscore.png" alt="underscore logo" style="width: 100%; max-width: 300px;">
						<br>
						<ul>
							<li class="fragment">1st Generation Library</li>
							<li class="fragment">Cross-browser compatibility</li>
							<li class="fragment">JavaScript utility library</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li><strong>Underscore: </strong>In the era when Internet Explorer 8 was still a consideration in JavaScript programming, underscore had a clear purpose: to make JavaScript’s functional methods cross-browser compatible. (eg: map(), reduce(), etc…)</li>
								<li><strong>Underscore</strong> is a JavaScript utility library that provides helper functions for common idioms with a focus on functional programming.</li>
							</ul>
						</aside>
					</section>

					<section class="fragments">
						<h2>Functional Programming</h2>
						<p>LoDash</p>
						<img src="images/lodash.png" alt="lodash logo" style="width: 100%; max-width: 150px;">
						<br>
						<ul>
							<li class="fragment">Preferred alternative to Underscore</li>
							<li class="fragment">loadash/fp module</li>
							<li class="fragment">Generic utility belt</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li><strong>LoDash: </strong>The lodash/fp module is an instance of lodash with its methods wrapped to produce immutable auto-curried iteratee-first data-last methods.</li>
								<li>loadash/fp is more of a generic utility belt than Ramda is.</li>
							</ul>
						</aside>
					</section>

					<section class="fragments">
						<h2>Functional Programming</h2>
						<p>Ramda</p>
						<img src="images/ramda.jpg" alt="Ramda logo">
						<ul>
							<li class="fragment">2nd generation functional programming library</li>
							<li class="fragment">Javascript feel</li>
							<li class="fragment">Lots of breaking changes, because it hasn't reached 1.0</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li><strong>Ramda: </strong>Considered a 2nd generation functional programming language</li>
								<li>Using Ramda should feel much like just using Javascript.  Ramda's basic data structures are plain Javascript objects, and their usual collections are Javascript arrays. Ramda also keep other native features of Javascript, such as functions as objects with properties.</li>
								<li>Ramda emphasizes a purer functional style. Immutability and side-effect free functions are at the heart of its design philosophy. This can help you get the job done with simple, elegant code.</li>
								<li>Ramda functions are automatically curried. This allows you to easily build up new functions from old ones simply by not supplying the final parameters.</li>
								<li>The parameters to Ramda functions are arranged to make it convenient for currying. The data to be operated on is generally supplied last.</li>
								<li>Ramda, however,  is still going through significant changes. Lots of breaking changes, because it hasn't reached 1.0</li>
							</ul>
						</aside>
					</section>

				</section>

				<!-- WHY FP SLIDES/SECTION -->
				<section>
					<section>
						<h2>Functional Programming</h2>
						<p>
              Why bother?
						</p>
						<img src="images/whybotherguy.jpg" width=400px alt="why bother?">

				</section>

        	<section class="fragments">
						<h2>Functional Programming</h2>
						<p>Functional Programming encourages functions that:</p>
						<ul>
							<li class="fragment">accept at least one argument</li>
							<li class="fragment">return at least one value</li>
              <li class="fragment"><u>avoid mutating data ouside of its
                  own scope</u></li>
						</ul>
					</section>

          <section class="fragments">
            <h2>When you don't mutate global state...</h2>
            <p>You drastically reduce the likelihood of bugs</p>
              <ul>
                <li class="fragment">Functions are no longer affected by
                "hidden state"</li>
                <li class="fragment">You circumvent race conditions which occur
                when output is dependent on a sequence of uncontrollable events
                such as the network, device latency, user input or anything
                that occurs randomly. E.g. Google Instant</li>
                <li class="fragment">"Reliance upon state is one of the largest
                contributors to system complexity"</li>
                <li class="fragment"><img src='images/prevention.png'
                width=400px alt='An ounce of prevention is worth a pound of
                cure'></li>
              </ul>

              <aside class="notes">
              <p>Example: years ago developers were trying to copy “Google
              Instant” -> the autocomplete feature that displays instant search
              results as you type your query.  The problem: Users often type
              faster than autocomplete ajax call search response could be
              returned, which would trigger race conditions.  Newer suggestions
              would be replaced by outdated suggestions.  Why? Each AJAX
              success handler was given access to directly update the
              suggestion list that was displayed to users. The slowest request
              would always win by replacing results, even when those results
              were newer.  Solution: a “result suggestion” manager that is
              aware of pending ajax requests and when the user typed something
              new.  The pending request would be cancelled before a new request
              was issued, so only a single response handler could update the
              UI.
              </p>
              <p>
              The biggest problem in the development and maintenance of
              large-scale software systems is complexity -- large systems are
              hard to understand.  And the biggest contributor is the handling
              of state.
              </p>
              </aside>
              </section>

          <section class="fragments">
            <h2>When you don't mutate global state...</h2>
            <p>Debugging becomes easier</p>
              <ul>
                <li class="fragment">There's no guesswork about how a function
                will perform at different points in the program.</li>
                <li class="fragment">The function can be easily isolated to
                check values</li>
              </ul>
              </section>

          <section class="fragments">
            <h2>When you don't mutate global state...</h2>
            <p>Changing the code is less painful</p>
              <ul>
                <li class="fragment">Without relying on state, changes touch
                far less of your code</li>
                <li class="fragment">The code becomes easily testable</li>
                <li class="fragment">Unit tests are a breeze to write when
                a function only relies on arguments passed directly to it</li>
                <li class="fragment">Tests help you maintain your code and save
                future-you from having to remember what the code needs to do.
                Failed tests will remind you!</li>
                <li class="fragment"><img src='images/unittests.jpg'
                width=400px alt='I should start writing unit tests'> </li>
              </ul>

              </section>


          <section class="fragments">
            <h2>Pure functions are more reusable</h2>
            <p></p>
              <ul>
                <li class="fragment">Functional programming encourages functions that are short, simple, and do one thing</li>
                <li class="fragment">Function names become expressive and
                meainingful (e.g. "hasID" or "addsTimeStamp")</li>
                <li class="fragment">Short functions are easier to
                understand</li>
                <li class="fragment">Smaller functions can be reused as part of
                more complex tasks</li>
                <li class="fragment">When higher-level functions are composed
                of smaller functions they become more robust, less
                fragile.</li>
                <li class="fragment"><img src='images/legodino.jpg' width=400px alt='An ounce of prevention is worth a pound of
                cure'></li>
              </ul>
              </section>

          <section class="fragments">
            <h2>Pure functions can be cached</h2>
            <p></p>
              <ul>
                <li class="fragment">When you cache using 'memoization' you get
                better performance</li>
                <li class="fragment">Recursive functions, normally too
                expensive, become viable</li>
              </ul>

              </section>
              <section>
              <pre><code>
var memoize = function(f) {

  //create a cache
  var cache = {};

  return function() {
    var arg_str = JSON.stringify(arguments);

    //If we already have the answer in our cache, do nothing
    //Otherwise, store the result of this function call in our cache
    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);

    return cache[arg_str];
  };
};

function fibonacci(n) {
  return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);
};

function betterFibonacci = memoize(function(n) {
  return (n === 0 || n === 1) ? n : betterFibonacci(n - 1) + betterFibonacci(n - 2);
});

var ITERATIONS = 42;

console.time('non-memoized');
console.log(fibonacci(ITERATIONS));
console.timeEnd('non-memoized'); // 3788ms

console.time('memoized');
console.log(betterFibonacci(ITERATIONS));
console.timeEnd('memoized'); // 1ms !!!
</pre></code>
</section>

              <section>
              <h2>The best part...</h2>
              <ul>
                <li class="fragment">You don't have to completely abandon your
                current practices!</li>
                <li class="fragment">Functional code can live next to Object
                Oriented code</li>
                <li class="fragment">An existing code base can be updated gradually</li>
                <li class="fragment">Learning and using a few patterns of
                functional programming is a great start towards cleaner and
                more elegant code</li>
              </section>

              </section>

              </section>

							<!-- WHY FP SLIDES/SECTION -->
							<section>
								<section>
									<h2>Functional Programming</h2>
									<h3>The Great Debate</h3>
									<p>
										Functional Programming vs. Object Oriented Programming
									</p>
									<img src="images/fighting.gif" alt="Everybody was kung-fu fighting">

									<!-- notes -->
									<aside class="notes">
										<small>
											<ul>
												<li>For better applications, we need a simple and reliable manner to do it.  In Functional Programming, we’re given those features.  Pure Functions and Immutable State alone give us the ability to run a function a thousand times and still get the same result.</li>
											</ul>
										</small>
									</aside>
								</section>

								<section>
									<h2>Functional Programming</h2>
									<h3>Why FP over OO?</h3>
									<blockquote> “The problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.”</blockquote>
									<cite class="text-align-right">-Joe Armstrong</cite>

									<!-- notes -->
									<aside class="notes">
										<small>
											<ul>
												<li>Because Object Oriented Programming relies directly on mutable state, the objects methods you call are supposed to mutate the current this.  There’s a lot of complex processes that need to be written just to manage all of the threads in your program to keep them correctly updated and synchronized.  With a functional approach, we don’t need to worry about this.</li>
												<li>Instead functions are broken down to very small methods that are then utilized in first-class and high-order functions that are more complex.  This makes our code not only easier to read as we have pointed out before, it also makes it easier to understand.  Because function names become expressive and meaningful, code becomes more readable and declarative.</li>
											</ul>
										</small>
									</aside>
								</section>
							</section>
				<!-- LAST SLIDE -->
				<section>

					<section class="">
						<h2>The End</h2>
						<p class="text-align-left">Functional programming is a style that emphasizes and enables the writing of smarter code, which minimizes complexity and increases modularity.</p>
						<img src="images/fp-dino.jpg" alt="fp dino">

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>It's a way of writing cleaner code through clever ways of mutating, combining, and using functions.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
						<h2>The End</h2>
						<p>JavaScript provides an excellent medium for this approach.</p>
						<img src="images/gage-x.jpg" alt="Happy Gage - The Buddliest Bud" style="width: 100%; max-width: 300px; position: relative; top: -20px;">

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>It's a way of writing cleaner code through clever ways of mutating, combining, and using functions.</li>
									<li>JavaScript is actually a functional language at heart</li>
									<li>By learning how to expose its true identity as a functional language, we can implement web applications that are powerful, easier to maintain, and more reliable</li>
									<li>By doing this, JavaScript's odd quirks and pitfalls will suddenly become clear and the language as a whole will make infinitely more sense.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section>
						<h2>Resources</h2>
						<small>
							<ul>
								<li><a href="https://psdtowp.net/learn-javascript.html" target="_blank">Learn JavaScript: The best methods and resources according to 25 JavaScript experts</a></li>
								<li><a href="https://auth0.com/blog/2016/03/23/intro-to-immutable-js/" target="_blank">Introduction to Immutable.js and Functional Programming Concepts</a></li>
								<li><a href="https://www.gitbook.com/book/drboolean/mostly-adequate-guide/details" target="_blank">Mostly Adequate Guide to Functional Programming</a></li>
								<li><a href="http://eloquentjavascript.net/1st_edition/chapter6.html" target="_blank">Eloquent JavaScript - Functional Programming </a></li>
								<li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4#.hsra264om" target="_blank">The Two Pillars of JavaScript — Pt 2: Functional Programming</a></li>
								<li><a href="https://medium.com/@collardeau/intro-to-functional-programming-concepts-in-javascript-b0650773139c#.plketwxa1" target="_blank">An Intro to Functional Programming Concepts in JavaScript</a></li>
								<li><a href="https://hughfdjackson.com/javascript/why-curry-helps/" target="_blank">Why Curry Helps</a></li>
								<li><a href="http://lucasmreis.github.io/blog/pointfree-javascript/" target="_blank">Point-free JavaScript</a></li>
								<li><a href="http://fr.umio.us/why-ramda/" target="_blank">Why Ramda?</a></li>
								<li><a href="https://medium.com/@jugoncalves/functional-programming-should-be-your-1-priority-for-2015-47dd4641d6b9#.u2649jxjf" target="_blank">Functional Programming should be your #1 priority for 2015</a></li>
								<li><a href="https://github.com/timoxley/functional-javascript-workshop" target="_blank">Functional JavaScript Workshop</a></li>
								<li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976#.umux9e8mh" target="_blank">Master the JavaScript Interview: What is a Pure Function?</a></li>
								<li><a href="http://curtclifton.net/papers/MoseleyMarks06a.pdf" target="_blank">Reliance on state, the largest contributor to system complexity</a></li>
								<li><a href="http://requiremind.com/memoization-speed-up-your-javascript-performance/" target="_blank">Cacheing Pure Functions and Memoization</a></li>
								<li><a href="https://blog.pivotal.io/labs/labs/all-evidence-points-to-oop-being-bullshit" target="_blank">All evidence points to OOP being bullshit</a></li>
								<li><a href="http://codepen.io/Universalist/post/predicates-in-javascript" target="_blank">Predicates in Javascript</a></li>
								<br>
								<li><a href="https://github.com/hookerz/779-yt-beacon5/tree/lilly-inception-refactor/lilly-inception" target="_blank">Lilly Inception - Refactored</a></li>
							</ul>
						</small>

					</section>

				</section>

			</div> <!-- slides -->

		</div> <!-- reveal -->

		<div id="loadingOverlay">
			<img src="images/logo.png" alt="hook logo">
		</div>


		<script src="js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'js/plugin/zoom-js/zoom.js', async: true },
					{ src: 'js/plugin/notes/notes.js', async: true }
				]
			});

		</script>

		<!-- <script src="js/vendor.js"></script> -->
		<script src="js/main.build.js"></script>

	</body>
</html>
