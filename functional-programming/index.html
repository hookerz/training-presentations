<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Functional Programming Presentation</title>

		<meta name="description" content="A presentation on the Functional Programming paradigm">
		<meta name="author" content="Hook">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link href='https://fonts.googleapis.com/css?family=Roboto+Condensed' rel='stylesheet' type='text/css'>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/zenburn.css">
		<link rel="stylesheet" href="css/hook.css">
		<link rel="stylesheet" href="css/index.css">

	</head>

	<body>

		<div class="reveal">

			<!-- hook svg -->
			<a href="http://www.byhook.com" target="_blank" id="logoLink">
				<svg version="1.1" id="logo" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
				   viewBox="0 0 88 131" style="enable-background:new 0 0 88 131;" xml:space="preserve">
				  <g>
				    <g>
				      <path class="logo-fill" d="M63.7,0.1L63.7,0.1C44.3,0.1,44.3,14.9,44.3,24v14.7c0,9.1,0,23.9,19.3,23.9h0C83,62.7,83,47.9,83,38.7V24
				        C83,14.9,83,0.1,63.7,0.1z M68.2,42.2c0,2.2,0,5.7-4.6,5.7s-4.6-3.5-4.6-5.7V20.6c0-2.2,0-5.7,4.6-5.7s4.6,3.5,4.6,5.7V42.2z"/>
				      <path class="logo-fill" d="M24,1.2v21.6c0,0.7-0.5,1.2-1.2,1.2h-6.9c-0.7,0-1.2-0.5-1.2-1.2V1.2c0-0.7-0.5-1.2-1.2-1.2H1.2
				        C0.5,0,0,0.5,0,1.2V24v14.8v22.7c0,0.7,0.5,1.2,1.2,1.2h12.3c0.7,0,1.2-0.5,1.2-1.2V39.9c0-0.7,0.5-1.2,1.2-1.2h6.9
				        c0.7,0,1.2,0.5,1.2,1.2v21.6c0,0.7,0.5,1.2,1.2,1.2h12.3c0.7,0,1.2-0.5,1.2-1.2V38.8V24V1.2c0-0.7-0.5-1.2-1.2-1.2H25.2
				        C24.5,0,24,0.5,24,1.2z"/>
				    </g>
				    <path class="logo-fill" d="M19.3,68.5L19.3,68.5C0,68.5,0,83.2,0,92.4v14.7c0,9.1,0,23.9,19.3,23.9h0c19.3,0,19.3-14.7,19.3-23.9V92.4
				      C38.7,83.2,38.7,68.5,19.3,68.5z M23.9,110.5c0,2.2,0,5.7-4.6,5.7h0c-4.6,0-4.6-3.5-4.6-5.7V88.9c0-2.2,0-5.7,4.6-5.7h0
				      c4.6,0,4.6,3.5,4.6,5.7V110.5z"/>
				    <path class="logo-fill" d="M72.5,131H87c0.8,0,1.3-0.8,0.9-1.5l-15.8-29.3c-0.1-0.3-0.2-0.6,0-0.9l12.5-29.6c0.3-0.7-0.2-1.4-0.9-1.4
				      H69.8c-0.4,0-0.8,0.2-0.9,0.6l-9.2,21.8C59.5,91.1,59,91,59,90.6V69.4c0-0.6-0.5-1-1-1H45.3c-0.6,0-1,0.5-1,1V130c0,0.6,0.5,1,1,1
				      H58c0.6,0,1-0.5,1-1v-21.6c0-0.4,0.5-0.5,0.6-0.2l12,22.3C71.8,130.8,72.1,131,72.5,131z"/>
				  </g>
				</svg>
			</a>

			<div class="slides">
				<!-- INTRO SLIDE -->
				<section>
					<h2>Functional Programming</h2>
					<h3>A true renewal of thoughts</h3>
					<img src="images/robit.png" alt="Robot picture" class="text-align-center">
					<p>
						<small>Created by <a href="http://byhook.com/" target="_blank">Hook Studios</a></small>
					</p>
				</section>

				<section>
					<h2>What is Functional Programming?</h2>
					<!-- notes -->
					<aside class="notes">
						<small>
							<ul>
								<li>Functional programming is a paradigm where you believe that functions are the most important part of your program.  Data is immutable in functional programming, that is to say that it should never change.  Functional programming operates in a stateless manner, meaning that functions should perform every task as if it was called for the first time, with no knowledge of the future or the past.  In functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function f twice with the same value for an argument x will produce the same result f(x) each time.</li>
								<li><strong>Sidenote:</strong></li>
								<li>This does not mean you don't have objects though! It just means that instead of telling an object to do something, you pass the object to a function, which does something. The important thing to note is that this function does not modify the original object. It might return a modified copy of the object, but the original object is not changed.  Such functions are called pure functions.</li>
							</ul>
						</small>
					</aside>
				</section>
				<!-- CORE CONCEPTS SLIDES/SECTION -->
				<section>

					<section>
						<h2>Functional Programming</h2>
						<h3>Core Concepts</h3>
						<img src="images/core.jpg" alt="Apple Core" style="width: 100%; max-width: 350px;">
					</section>

					<section class="fragments">
            <h4>Core Concepts:</h4>
            <h2>First-Class functions</h2>
						<p> "An entity which supports all the operations generally available to other entities” such as</p>
						<ul>
							<li class="fragment">Being passed as an argument</li>
							<li class="fragment">Being returned from a function</li>
							<li class="fragment">Being assigned to a variable</li>
							<li class="fragment">In other words: An object that also happens to be a function.</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>The concept was introduced in the 1960s, as older, imperative languages like Fortran IV and C don’t support array assignment or passage as an argument.</li>
									<li>First Class functions are a necessity for functional programming, because without them we couldn’t use higher-order functions!</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
						<h2>First-Class Functions</h2>
						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
// Function declaration. Okay but can't be nested within non-function blocks
// The whole thing gets hoisted at compile time. (beware)
function double(x) {
	return x * x;
}
							</code>
						</pre>
						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// Function expression, first class! 'var double = undefined' gets hoisted
// but the definition itself does not. (so chill)
var double = function(x) {
	return x * x;
}
							</code>
						</pre>
						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>

// function can be stored in an array, first class!
var myArray = [5, 'socks', {a: 3}, double, false, Nan, []];
							</code>
						</pre>
						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
var nums = [1, 1, 2, 3, 5, 8];

// functon can be passed as an argument, first class!
var sum = nums.map(double); // [1, 1, 4, 9, 25, 64]
							</code>
						</pre>

</section>
            <section>
								<h2>First class functions are supported by</h3>
								<ul>
									<li>Python</li>
									<li>Go</li>
									<li>Rust</li>
									<li>C#</li>
									<li>Javascript</li>
									<li>All functional languages (Scheme, Haskell, Scala)</li>
									<li>...and many more</li>
								</ul>
						</section>

					<section class="fragments">
            <h4>Core Concepts:</h4>
            <h2>Higher-Order functions</h2>
						<ul>
							<li class="fragment">Functions that can receive other functions as parameters OR return functions OR both.</li>
							<li class="fragment">Functions that operate on other functions are called higher-order functions. By operating on functions, they can talk about actions on a whole new level.</li>
							<li class="fragment">Higher-order functions can be used to generalize many algorithms that regular functions cannot easily describe.</li>
						</ul>

					</section>

					<section class="fragments">
						<h2>Higher-Order Functions</h2>
						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
function or(p1, p2) {
	return function(x) {
		return p1(x) || p2(x);
	}
}

							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
function negative(x) {
	return x < 0;
}

function positive(x) {
	return x > 0;
}

var nonzero = or(negative, positive);
alert(nonzero(-5));
alert(nonzero(0));
alert(nonzero(5));
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>A predicate is a function that takes one item as input and returns either true or false based on whether the item satisfies some condition.  Great for interrogating objects to learn more about them, or apply operations conditionally to objects.</li>
									<li>Javascript supports passing functions around as values, so we can make predicate combinators: functions that build new predicates from simpler ones.</li>
									<li>sometimes called the combinator pattern: emphasizes creating systems by making simple primitives first then making tools for combining them into more complex objects.</li>
									<li>This function consumes two predicates, p1 and p2, and returns a new predicate function.  That predicate tests a value x and returns true if either p1(x) is true or p2(x) is true.</li>
									<li>By using OR we combine NEGATIVE and POSITIVE to get a new function called NONZERO, which returns true if its argument is either negative or positive.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section>
            <h4>Core Concepts:</h4>
						<h2>Pure functions</h2>
						<img src="images/PureMichigan.jpg" alt="Pure Michigan Image" style="width: 100%; max-width: 200px;">

						<!-- notes -->
						<aside class="notes">
							<p>A function that, given the same input, will always return the same output and does not have any observable side-effects.</p>
						</aside>

					</section>

					<section class="fragments">

						<h2>What's a side effect?</h2>

						<ul>
							<li class="fragment">Changing the file system</li>
							<li class="fragment">Mutating outside variables</li>
							<li class="fragment">Getting user input</li>
							<li class="fragment">Accessing system state</li>
							<li class="fragment">Adding a new variable to a data structure</li>
						</ul>

					</section>

					<section>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
let array = [1, 2, 3, 4, 5];
							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// pure
array.slice(0, 2);
console.log(`[${array}]`); // [1,2,3,4,5]

array.slice(0, 2);
console.log(`[${array}]`); // [1,2,3,4,5]

array.slice(0, 2);
console.log(`[${array}]`); // [1,2,3,4,5]
							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// impure
array.splice(0, 2);
console.log(`[${array}]`); // [3,4,5]

array.splice(0, 2);
console.log(`[${array}]`); // [5]

array.splice(0, 2);
console.log(`[${array}]`); // []

							</code>
						</pre>
					</section>

					<section>

						<img src="images/pulp.png" alt="Pulp Fiction reference">

						<!-- notes -->
						<aside class="notes">
							<p>Lastly, it’s important to mention immutable state.  That is to say - the state cannot change.  In multi-threaded applications, this is a great thing.  It allows the thread to act on data without worrying what other threads are up to.</p>
						</aside>

					</section>

					<section class="fragments">
            <h4>Core Concepts:</h4>
						<h2>Closures</h2>
						<p><strong>Closure</strong>: A loveable concept</p>
						<ul>
							<li class="fragment">Only accessible to a specific returning function.</li>
							<li class="fragment">Place nicely with pure functions.</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<p>Closure.  We all love and know it already, but just to overview:</p>

							<ul>
								<li>Data saved inside a function that is only accessible to a specific returning function.</li>
								<li>This of course plays nicely with pure functions as we only mutate internal variables in a functional approach.</li>
							</ul>
						</aside>

					</section>

					<section class="fragments">
						<h2>Closures</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
let add = function(a){
  return function(b){
    return a + b;
  }
};
							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// the variable 'a' is enclosed and
// is only accessible to the returning function.

let add10 = add(10);
let result = add10(20);

console.log(result);
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<p>Closures have three scope chains:  It has access to its own scope, the outer function’s variables and of course global variables - but we don’t use global variables in functional programming.</li>
							</p>
						</aside>

					</section>

				</section>

					</section>
				<!-- BASICS SLIDES/SECTION -->
				<section>
					<section>
						<h2>Functional Programming</h2>
						<h3>Basics Practices</h3>
						<img src="images/functions-in-out.png" alt="Functional Programming diagram" style="width: 100%; max-width: 300px; height: auto;">

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>So we’ve talked about and defined the what, now for the why...</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
						<h2>Functional Programming</h2>
						<p>Have you heard of Ramda or currying?</p>

						<img src="images/goku.gif" alt="Goku eating some curry" class="fragment">

						<p class="fragment">Not quite....</p>

					</section>

					<section>
						<h4>The Basics</h4>
						<h2>Currying</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
// normal - regular addition
let add = (a, b) => a + b;

// let add = function(a, b) {
//   return a + b;
// };

console.log(`Normal JS Invocation: ${add(1, 2)}`); // 3
console.log(`Normal JS Invocation: ${add(1, 2, 'IGNORE ME')}`); // 3
console.log(`Normal JS Invocation: ${add(1)}`); // NaN

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>The concept is simple: You can call a function with fewer arguments than it expects. It returns a function that takes the remaining arguments.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section>
						<h2>Currying</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
// curried - curried addition
// a curried function is one where multiple arguemnts are described by a
// series of one-argument functions.
let addCurried = a => b => a + b;

// let addCurried = function(a) {
//   return function(b) {
//     return a + b;
//   };
// };

let cAdd = addCurried(1);

console.log(`Curried: ${cAdd(2)}`); // 3
console.log(`Curried: ${cAdd(2, 'IGNORE ME')}`); // 3

// ramda - makes stuff easier
let ramdaCurried = R.curry(add);

let rAdd = ramdaCurried(1);

console.log(`Curried: ${rAdd(2)}`); // 3
console.log(`Curried: ${rAdd(2, 'IGNORE ME')}`); // 3
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<p>Thankfully the Ramda library makes currying things much easier.</p>
							</small>
						</aside>

					</section>

					<section class="fragments">
						<h2>Currying</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
let objects = [{ id: 1 }, { id: 2 }, { id: 3 }];

console.log(`w/o Curry: [${objects.map(o => o.id)}]`); // [1, 2, 3]

let get = R.curry((property, object) => {
  return object[property];
});

console.log(`w/ Curry: [${objects.map(get('id'))}]`); // [1, 2, 3]
							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// Take it even further!
let map = R.curry((fn, value) => value.map(fn));

let getIDS = map(get('id'));

console.log(`Super Ultra Functional: [${getIDS(objects)}]`); // [1, 2, 3]
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Currying has it’s advantages, let’s say we wanted to map over an array of objects to get an id.  Easy enough, but if we apply curry and make a get function, we can get a bit cleaner.</li>
									<li>Even further, we can actually rewrite the map function to accept another function and map that value.  Leaving us with some super clean code no doubt.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section>

						<img src="images/arrow-functions.jpg" alt="Arrow Functions">

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Is it really necessary though?  Even in the examples provided, I’m using ES6 and we all know arrow functions greatly reduce visual noise and make code look pretty already.  Supplying a curried function with too few arguments is an easy mistake to make and it can often only cause an error at a much later stage in code.  Embedded in a complex codebase of many of the applications and websites we build - it can be easy to waste a handful of hours searching for the origins of a mysterious function.</li>
									<li>Is it actually necessary to curry everything?  The answer is no - probably not.  Can it impede a programmer's ability in real world practice?  That’s up for debate, regardless - I think most are in agreement that arrow functions work great and solve most of the problems that currying solves.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
						<h4>The Basics</h4>
						<h2>Composition</h2>
						<ul>
              <li class="fragment"><strong>Function Composition: </strong>The
              combination of simple functions to build more sophisticated
              ones.</li>
              <li class="fragment"> Composing functions allows us to build complex functions from many simple, generic functions.</li>
							<li class="fragment">By treating functions as building blocks for other functions, we can build truly modular applications with excellent readability and maintainability.</li>
						</ul>
					</section>

					<section class="fragments">
						<h2>Composition</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
// function that combines two functions together:
// run function 'f' on the result of function 'g'
var compose = function(f, g) {
  return function(x) {
	  return f(g(x));
  };
};

// ES6 hyper-terse equivalent
const compose = (f, g) => (x) => f(g(x));

const upperCase = (str) => str.toUpperCase();
const trim = (str) => str.replace(/^\s+I\s+$/g, '');
const replaceIWithBang = (str) => str.replace(/[i]/g, '!');

const labelMaker = compose(upperCase, trim);
// Ramda's built-in compose method takes any number of functions and
// will return them right-to-left
const coolLabelMaker = R.compose(upperCase, replaceIWithBang, trim);

let labels = [' iconic ', 'high five    ', ' bim bap'].map(labelMaker);
let coolLabels = [' iconic ', 'high five    ', ' bim bap'].map(coolLabelMaker);

console.log(labels); // [ 'ICONIC', 'HIGH FIVE', 'BIM BAP']
console.log(coolLabels); // ["!CON!C", "H!GH F!VE", "B!M BAP"]

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
<li> Types of things we might want to compose: multi-step processes with stages
that also occur in other multi-step processes - stages we might want to
recreate later."</li>
<li>Example: make a "label maker" function composed of "trim" and
"upperCase".</li>
									<li>Thank heavens Ramda has a method, R.compose so we don’t have to write our own (gets pretty gnarly when writing a custom compose function that takes more than two functions).</li>
								</ul>
							</small>
						</aside>
          </section>

          <section class="fragments">
          <h2>Composing in the wild</h2>
          <p>Generating a valid HTTP request using an oauth signature</p>
          <ul>
            <li>request method (GET or POST)</li>
            <li>base url ('https://api.twitter.com/1/statuses/update.json')</li>
            <li>request parameters (status="Best tacos")</li>
            <li>oauth parameters (consumer key, method, timestamp, token, oauth
            version)
              <ul>
                <li>Percent encode every key and value that will be signed</li>
                <li>Sort the list of parameters alphabetically by encoded
                key</li>
                <li>For each key/value pair:
                  <ul>
                  <li> append encoded key to the output
                  string</li>
                  <li>Append the '=' character to the output string.</li>
                  <li>If there are any key/value pairs remaining, append the '&'
                  character to the output string.</li>
                  </ul>
              </ul>
            </li>
          </ul>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
<li>Using Yelp or Twitter's API necessitates generating a valid HTTP request
with an oauth signature.  There are many libraries out there for this.</li>
									<li>Thank heavens Ramda has a method, R.compose so we don’t have to write our own (gets pretty gnarly when writing a custom compose function that takes more than two functions).</li>
								</ul>
							</small>
						</aside>
              </section>


					<section>
    				<h4>The Basics</h4>
						<h2>Functors</h2>

						<img src="images/funk.jpg" alt="We want the funk">
						<p>Not to be confused with funk-sters</p>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Term "Functor" comes from Category Theory, a mathmatical concept</li>
									<li>I won't begin to try and explain it's place in math, but as far as computer programming goes, let’s just say that category theory is simply "connecting the dots".</li>
									<li>Some quick terminolgy</li>
									<li><strong>Catgories</strong> are just sets with the same type. In JavaScript, they're arrays or objects that contain variables that are explicitly declared as numbers, strings, Booleans, dates, nodes, and so on.</li>
									<li><strong>Morphisms </strong>are pure functions that, when given a specific set of inputs, always return the same output.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
						<h2>Functors</h2>
						<ul>
							<li class="fragment">Functors map between categories.</li>
							<li class="fragment">They can be thought of as functions that lift values out of a container, morph them, and then put them into a new container.</li>
							<li class="fragment">The first input is a morphism for the type and the second input is the container.</li>
						</ul>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// Note that the type signature for functors looks like so

// my functor :: (a -> b) -> f a -> f b

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>This says, "give me a function that takes a and returns b and a box that contains a(s), and I'll return a box that contains b(s).</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
						<h2>Functors</h2>
						<p class="text-align-left">We already have one functor: map(). It grabs the values within the container, an array, and applies a function to it.</p>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
var nums = [1, 4, 9];

nums.map(Math.sqrt); // [1, 2, 3]

							</code>
						</pre>

						<small><p class="fragment">However, we'll need to write it as a global function and not as a method of the array.  This allows us to write cleaner, safter code later on.</p></small>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
// map :: (a -> b) -> [a] -> [b]
var map = function(f, a) {
	return arr(a).map(func(f));
}

							</code>
						</pre>
					</section>

					<section>

						<h2>Functional Programming</h2>
						<img src="images/thou.jpg" alt="Colonial guy">
					</section>

					<section>
            <h4>The Basics</h4>
						<h2>map()</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
let array = [0, 1, 2, 3, 4, 5];

// a basic map function
array.map((element, index) => {
  console.log(`Element: ${element} <br/>`);
  console.log(`Index: ${index} <br/>`);
});

// for loop comparison
for(let i = 0; i < array.length; i++) {
  console.log(`Element: ${array[i]} <br/>`);
  console.log(`Index: ${i} <br/>`);
};

// index is optional!
// a basic map function
array.map((element) => {
  console.log(`Element: ${element} <br/>`);
});

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Map… I think we’re all pretty familiar with the function, specifically because we just used it in our previous example, that said - it never hurts to recap.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section>
						<h4>The Basics</h4>
						<h2>map()</h2>

						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
const map = (fn, value) => value.map(fn);
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Now let’s talk about how map applies to functional programming.</li>
									<li>Map takes a function and a functor and applies the function to each of the functor’s values and returns a functor of the same shape.</li>
									<li>The Verdict? Map is awesome and is a tool you’ll find yourself using very often.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
            <h4>The Basics</h4>
						<h2>filter()</h2>
						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
arr.filter(callback [, argument]);

							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
var myarray = [1,2,3,4];
var words = 'hello 123 world how 345 ya doing'.split(' ');
var re = '[a-zA-Z]';

// remove all negative numbers
[-2,-1,0,1,2].filter(function(x){return x>0});

// remove null values after a map operation
words.filter(function(s){
  return s.match(re);
});

// remove random objects from an array
myarray.filter(function(){
  return Math.floor(Math.random()*2)
});

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>function is used to take elements out of an array</li>
									<li>callback must return <strong>True</strong> to include the item in the new array</li>
									<li><strong>False </strong>to drop it</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">

            <h4>The Basics</h4>
						<h2>reduce()</h2>
						<pre class="custom-pre">
							<code class="hljs" data-trim contenteditable>
arr.reduce(callback [, initialValue]);

							</code>
						</pre>

						<pre class="custom-pre fragment">
							<code class="hljs" data-trim contenteditable>
var numbers = [1,2,3,4];

// sum up all the values of an array
[1,2,3,4,5].reduce(function(x,y){return x+y}, 0);

// sum up all the values of an array
[1,2,3,4,5].reduce(function(x,y){return x+y}, 0);

// find the largest number
numbers.reduce(function(a,b){
  return Math.max(a,b)}) // max takes two arguments
);

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Sometimes called fold</li>
									<li>function is used to accumulate all the values of the array into one</li>
									<li>callback needs to return the logic to be performed to combine the objects</li>
									<li><strong>Numbers: </strong>usually added together to get a sum or multiplied together to get a product</li>
									<li><strong>Strings: </strong>often appended together</li>
								</ul>
							</small>
						</aside>
					</section>

				</section>

				<!-- LILLY INCEPTION REFACTOR SLIDES/SECTION -->
				<section>
					<section>
						<h2>Functional Programming</h2>
						<h3>Lilly Inception Refactor</h3>
						<img src="images/blah.jpg" alt="bla bla bla">
					</section>

					<section>
						<h3>Canvas.js - original version</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

var createjs = require('createjs');

var canvas;
var stage;
var exportRoot;

// set canvas id
var Canvas = function() {

  canvas = document.getElementById('you-line');

};

// initialize canvas animation
Canvas.prototype.init = function() {

  exportRoot = new lib02.Youtube_Beacon05_Lily_970x250();

  stage = new createjs.Stage(canvas);
  stage.addChild(exportRoot);
  stage.update();
  stage.enableDOMEvents(false);

};

// start canvas animation
Canvas.prototype.start = function() {

  canvas.style.opacity = 1;

  createjs.Ticker.setFPS(lib02.properties.fps);
  createjs.Ticker.addEventListener('tick', stage);

};

module.exports = Canvas;
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>OOP Constructor Function</li>
							</ul>
						</aside>

					</section>

					<section>

						<h3>Canvas.js - refactored</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

import createjs from 'createjs';

export default function() {

  const youLine = document.getElementById('you-line');
  const exportRoot = new lib02.Youtube_Beacon05_Lily_970x250();
  const stage = new createjs.Stage(youLine);

  const canvas = Object.create({});

  canvas.init = () => {

    stage.addChild(exportRoot);
    stage.update();
    stage.enableDOMEvents(false);

  };

  canvas.start = () => {

    youLine.style.opacity = 1;

    createjs.Ticker.setFPS(lib02.properties.fps);
    createjs.Ticker.addEventListener('tick', stage);

  };

  return canvas;

};

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>canvas = Object.create({});</li>
								<li>start() and init() are now arrow functions</li>
							</ul>
						</aside>

					</section>

					<section>

						<h3>Loader.js - original version</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

function Loader( manifest ) {

  this.manifest = manifest;
  this.loadItems = 0;
  this.loadItemsTotal = 0;
  this.loadComplete = false;
  this.consoleObject = {
    loaded: 0.0
  };

  manifest.forEach(function(item) {
    //console.log(item.src)
    this._loadImage(item.src);
  }.bind(this));

  this._loadScript('js/vendor.js');

}

Loader.prototype._loadImage = function( path ) {
  this.consoleObject[path] = false;
  var img = new Image();
  img.addEventListener( 'load', this._onLoad.bind( this, path ) );
  img.src = path;
  this.loadItemsTotal++;
};

Loader.prototype._loadScript = function( path ) {
  this.consoleObject[path] = false;
  global.Enabler.loadScript( global.Enabler.getUrl( path ), this._onLoad.bind( this, path ) );
  this.loadItemsTotal++;
};

Loader.prototype._onLoad = function ( id ) {
  this.loadItems++;
  this.consoleObject[id] = true;
  this.consoleObject.loaded = Math.round( ( this.loadItems / this.loadItemsTotal ) * 100 ) + '%';
  if ( this.loadItemsTotal === this.loadItems ) {
    this._onLoadComplete();
  }

};

Loader.prototype._onLoadComplete = function () {
  // this.callback();
  if (this.loadComplete === true) {
    return;
  }

  this.loadComplete = true;
  this._loadScript('js/main.build.js');
};

module.exports = Loader;
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>OOP Constructor Function</li>
							</ul>
						</aside>
					</section>

					<section>

						<h3>Loader.js - refactored</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

export default function(manifest) {

  //Loads all the images in the manifest
  const loadImage = function(path) {

    return new Promise((resolve, reject) => {

      let img = new Image();
      img.addEventListener('load', resolve);
      img.addEventListener('error', reject);
      img.src = path.src;

    });

  };

  //loads vendor and main.build scripts, individually
  const loadScript = function(path) {

    return new Promise((resolve, reject) => {
      global.Enabler.loadScript(global.Enabler.getUrl(path), resolve);

    });

  };

  const loadImagePromise = manifest.map(loadImage);
  const loadVendor =  loadScript('js/vendor.js');
  const loadMain = () => loadScript('js/main.build.js');

  //After all the images have loaded, then load in vendor, lastly load
  //mainbuild.js
  Promise.all(loadImagePromise.concat(loadVendor)).then(loadMain);

};


							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>using Promises</li>
							</ul>
						</aside>
					</section>

					<section>
						
						<h3>Animation.js - original version</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

var TweenMax = require('TweenMax');

var AnimationController = function () {

  // selectors
  this.player = document.querySelector('#player');
  this.animationWrap = document.querySelector('#animation');
  this.loader = document.querySelector('#loading');
  this.whiteBox = document.querySelector('#white-box');
  this.lillyText = document.querySelector('#lilly-text');
  this.fansText = document.querySelector('#fans-text');
  this.slash = document.querySelector('#slash');
  this.underlay = document.querySelector('#underlay');
  this.lozenge = document.querySelector('#lozenge');

  // booleans
  this.endOnce = true;

  this.init();

};

// initialize controller, build all timelines.
AnimationController.prototype.init = function() {

  this.globalTimeline = new TimelineMax({paused: true});

  this.globalTimeline.add(this.tl1(), 0.0);
  this.globalTimeline.add(this.tl2(), 21.25);

  return this.globalTimeline;

};

// timeline 0 - loading  wipe animation
AnimationController.prototype.tl1 = function () {

  this.tl1 = new TimelineMax();

  this.tl1.to([this.underlay, this.loader], 0.4, {autoAlpha: 0, ease: Power1.easeOut});

  return this.tl1;

};

// timeline 4 - last zoom in of branding
AnimationController.prototype.tl2 = function () {

  this.tl2 = new TimelineMax();

  this.tl2.fromTo(this.animationWrap, 3.225, {x: '-200%',
    autoAlpha: 1,
    scaleX: 10,
    scaleY: 10},
    {x: '0%',
    scaleX: 1,
    scaleY: 1,
    ease: Power3.easeOut});

  return this.tl2;

};

// make player visible, set animation wrap and fire tl0
AnimationController.prototype.start = function () {

  this.player.style.opacity = 1;
  this.globalTimeline.play();

};

// play animation
AnimationController.prototype.play = function () {

  this.globalTimeline.play();

};

// seek animation
AnimationController.prototype.seek = function(time) {

  this.globalTimeline.seek(time);

};

// pause animation
AnimationController.prototype.pause = function () {

  this.globalTimeline.pause();

};

// kill all animations, end banner
AnimationController.prototype.endState = function () {

  if (this.endOnce) {

    TweenMax.killAll(true, true, true, true);
    TweenMax.set(this.animationWrap, {autoAlpha: 1});
    this.endOnce = false;

  }

};

module.exports = AnimationController;
							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>OOP Constructor Function</li>
							</ul>
						</aside>

					</section>

					<section>

						<h3>Animation.js - refactored</h3>
						<pre class="bump-up">
							<code class="hljs" data-trim contenteditable>
'use strict';

import TweenMax from 'TweenMax';

export default function() {

    // selectors
    const player = document.querySelector('#player');
    const animationWrap = document.querySelector('#animation');
    const loader = document.querySelector('#loading');
    const whiteBox = document.querySelector('#white-box');
    const lillyText = document.querySelector('#lilly-text');
    const fansText = document.querySelector('#fans-text');
    const slash = document.querySelector('#slash');
    const underlay = document.querySelector('#underlay');
    const lozenge = document.querySelector('#lozenge');

    // timeline
    let timeline = null;

    // booleans
    let endOnce = true;

    const animation = Object.create({});

    animation.init = () => {

      timeline = new TimelineMax({paused: true});

      timeline.add(fadeOutLoader(), 0.0);
      timeline.add(animateBranding(), 21.25);

      return timeline;

    };

    function fadeOutLoader() {

      const tl = new TimelineMax();

      tl.to([underlay, loader], 0.4, {autoAlpha: 0, ease: Power1.easeOut});

      return tl;

    };

    function animateBranding() {

      const tl = new TimelineMax();

      tl.fromTo(animationWrap, 3.225, {x: '-200%',
        autoAlpha: 1,
        scaleX: 10,
        scaleY: 10},
        {x: '0%',
        scaleX: 1,
        scaleY: 1,
        ease: Power3.easeOut});

      return tl;

    };

    animation.start = () => {

      player.style.opacity = 1;
      timeline.play();

    };

    animation.play = () => timeline.play();

    animation.seek = (time) => timeline.seek(time);

    animation.pause = () => timeline.pause();

    animation.endState = () => {

      if (endOnce) {

        TweenMax.killAll(true, true, true, true);
        TweenMax.set(animationWrap, {autoAlpha: 1});
        endOnce = false;

      }

    };

    return animation;

};

							</code>
						</pre>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li>Use of ES6 import and export</li>
								<li>animation = Object.create({});</li>
								<li>play(), seek(), and init() are now arrow functions</li>
							</ul>
						</aside>

					</section>

					<section>
						<h2>Functional Programming</h2>
						<img src="images/refactor.jpg" alt="refactor image">
					</section>

				</section>

				<!-- FRAMEWORK SLIDES/SECTION -->
				<section>

					<section>
						<h2>Functional Programming</h2>
						<p>Let's talk Frameworks</p>
						<img src="images/frameworks.png" alt="different js framework logos">
					</section>

					<section class="fragments">

						<h2>Functional Progamming</h2>
						<p>React</p>
						<img src="images/react.png" alt="React.js logo" class="text-align-center">
						<br>
						<ul>
							<li class="fragment">Components provide abstractions</li>
							<li class="fragment">Composable Functions</li>
							<li class="fragment">Virtual DOM</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li><strong>React</strong>'s authors define it as a JavaScript library for creating UIs and addressing problem of building large applications with data that changes over time.  React brings the very basic essence of functional programming to the table. It provides abstractions such as components which are basically (pure) functions and get you away from imperatively touching the DOM.</li>
									<li>In terms of functional programming, you write composable functions. Data is coming to your functions as input which emit tree like representations as return values. When data changes, functions are re-run again with new data as input. React diffs the result of previous function call with new one and it effectively calculates the difference between the tree structures. From higher level perspective, React is a function which takes two DOMs and generates a list of DOM operations to be applied to the DOM.</li>
									<li>React’s rendering leverages the Virtual DOM - an in-memory representation of what the actual DOM should look like. When the state changes, React does a full re-render of the Virtual DOM, diffs it, and then patches the real DOM.</li>
								</ul>
							</small>
						</aside>

					</section>

					<section class="fragments">

						<h2>Functional Progamming</h2>
						<p>Deku</p>
						<img src="images/deku.png" alt="Deku.js logo" style="width: 100%; max-width: 250px;">
						<br>
						<ul>
							<li class="fragment">"Functional alternative to React"</li>
							<li class="fragment">Define your UI as a tree of components</li>
							<li class="fragment">Virtual DOM</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li><strong>Deku:</strong> Deku is a library for rendering interfaces using pure functions and virtual DOM.  It's the self proclaimed "functional alternative to React"
									<li>With Deku, you define your UI as a tree of components and whenever a state change occurs, it re-renders the entire tree to patch the DOM using a highly optimized diffing algorithm.
									</li>Instead of using classes and local state, Deku just uses functions and pushes the responsibility of all state management and side-effects onto tools like Redux. It also aims to support only modern browsers to keep things simple.</li>
								</ul>
							</small>
						</aside>

					</section>

					<section class="fragments">

						<h2>Functional Progamming</h2>
						<p>Vue</p>
						<img src="images/vue.jpg" alt="Vue.js logo" style="width: 100%; max-width: 300px;">
						<br>
						<ul>
							<li class="fragment">Provides reactive and composable View components</li>
							<li class="fragment">Uses the actual DOM as the template</li>
							<li class="fragment">Limited to environments where DOM is present</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li><strong>Vue: </strong>Vue.js, like React, provides reactive and composable View components.</li>
									<li>Instead of a Virtual DOM, Vue.js uses the actual DOM as the template and keeps references to actual nodes for data bindings. This limits Vue.js to environments where DOM is present. However, contrary to the common misconception that Virtual-DOM makes React faster than anything else, Vue.js actually out-performs React when it comes to hot updates, and requires almost no hand-tuned optimization.</li>
								</ul>
							</small>
						</aside>

					</section>

				</section>

				<!-- LIBRARIES SLIDE/SECTION -->
				<section>
					<section>
						<h2>Functional Programming</h2>
						<h3>Let's talk Libraries</h3>
						<img src="images/library.gif" alt="At the library like">
					</section>

					<section class="fragments">
						<h2>Functional Programming</h2>
						<p>Let's talk Libraries</p>
						<p class="text-align-left">As the years go, Internet Explorer 9 has faded into the past and native ES5 methods are expected for most applications. So the role of functional programming libraries has shifted from a compatibility layer to adding new, foundational methods for functional programming.</p>

					</section>

					<section class="fragments">
						<h2>Functional Programming</h2>
						<p>Underscore</p>
						<img src="images/underscore.png" alt="underscore logo" style="width: 100%; max-width: 300px;">
						<br>
						<ul>
							<li class="fragment">1st Generation Library</li>
							<li class="fragment">Cross-browser compatibility</li>
							<li class="fragment">JavaScript utility library</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li><strong>Underscore: </strong>In the era when Internet Explorer 8 was still a consideration in JavaScript programming, underscore had a clear purpose: to make JavaScript’s functional methods cross-browser compatible. (eg: map(), reduce(), etc…)</li>
								<li><strong>Underscore</strong> is a JavaScript utility library that provides helper functions for common idioms with a focus on functional programming.</li>
							</ul>
						</aside>
					</section>

					<section class="fragments">
						<h2>Functional Programming</h2>
						<p>LoDash</p>
						<img src="images/lodash.png" alt="lodash logo" style="width: 100%; max-width: 150px;">
						<br>
						<ul>
							<li class="fragment">Preferred alternative to Underscore</li>
							<li class="fragment">loadash/fp module</li>
							<li class="fragment">Generic utility belt</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li><strong>LoDash: </strong>The lodash/fp module is an instance of lodash with its methods wrapped to produce immutable auto-curried iteratee-first data-last methods.</li>
								<li>loadash/fp is more of a generic utility belt than Ramda is.</li>
							</ul>
						</aside>
					</section>

					<section class="fragments">
						<h2>Functional Programming</h2>
						<p>Ramda</p>
						<img src="images/ramda.jpg" alt="Ramda logo">
						<ul>
							<li class="fragment">2nd generation functional programming library</li>
							<li class="fragment">Javascript feel</li>
							<li class="fragment">Lots of breaking changes, because it hasn't reached 1.0</li>
						</ul>

						<!-- notes -->
						<aside class="notes">
							<ul>
								<li><strong>Ramda: </strong>Considered a 2nd generation functional programming language</li>
								<li>Using Ramda should feel much like just using Javascript.  Ramda's basic data structures are plain Javascript objects, and their usual collections are Javascript arrays. Ramda also keep other native features of Javascript, such as functions as objects with properties.</li>
								<li>Ramda emphasizes a purer functional style. Immutability and side-effect free functions are at the heart of its design philosophy. This can help you get the job done with simple, elegant code.</li>
								<li>Ramda functions are automatically curried. This allows you to easily build up new functions from old ones simply by not supplying the final parameters.</li>
								<li>The parameters to Ramda functions are arranged to make it convenient for currying. The data to be operated on is generally supplied last.</li>
								<li>Ramda, however,  is still going through significant changes. Lots of breaking changes, because it hasn't reached 1.0</li>
							</ul>
						</aside>
					</section>

				</section>

				<!-- WHY FP SLIDES/SECTION -->
				<section>
					<section>
						<h2>Functional Programming</h2>
						<p>
              Why bother?
						</p>
						<img src="images/whybotherguy.jpg" width=400px alt="why bother?">

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>Both OOP and FP have the shared goal of creating understandable, flexible programs that are free of bugs.</li>
									<li>Two primary components: the data (the stuff a program knows) and the behaviors (the stuff a program can do to/with that data).</li>
									<li>OOP says that bringing together data and its associated behavior in a single location (an Object) makes it easier to understand how a program works.</li>
									<li>FP says that data and behavior are distinctively different things and should be kept separate for clarity.</li>
								</ul>
							</small>
						</aside>
					</section>

        	<section class="fragments">
						<h2>Functional Programming</h2>
						<p>Functional Programming encourages functions that:</p>
						<ul>
							<li class="fragment">accept at least one argument</li>
							<li class="fragment">return at least one value</li>
              <li class="fragment"><u>avoid mutating data ouside of its
                  own scope</u></li>
						</ul>
					</section>

          <section class="fragments">
            <h2>When you don't mutate global state...</h2>
            <p>You drastically reduce the liklihood of bugs</p>
              <ul>
                <li class="fragment">Functions are no longer affected by
                "hidden state"</li>
                <li class="fragment">You circumvent race conditions which occur
                when output is dependent on a sequence of uncontrollable events
                such as the network, device latency, user input or anything
                that occurs randomly. E.g. Google Instant</li>
                <li class="fragment">"Reliance upon state is one of the largest
                contributors to system complexity"</li>
                <li class="fragment"><img src='images/prevention.png'
                width=400px alt='An ounce of prevention is worth a pound of
                cure'></li>
              </ul>
              </section>

          <section class="fragments">
            <h2>When you don't mutate global state...</h2>
            <p>Debugging becomes easier</p>
              <ul>
                <li class="fragment">There's no guesswork about how a function
                will perform at different points in the program.</li>
                <li class="fragment">The function can be easily isolated to
                check values</li>
              </ul>
              </section>

          <section class="fragments">
            <h2>When you don't mutate global state...</h2>
            <p>Changing the code is less painful</p>
              <ul>
                <li class="fragment">Without relying on state, changes touch
                far less of your code</li>
                <li class="fragment">The code becomes easily testable</li>
                <li class="fragment">Unit tests are a breeze to write when
                a function only relies on arguments passed directly to it</li>
                <li class="fragment">Tests help you maintain your code and save
                future-you from having to remember what the code needs to do.
                Failed tests will remind you!</li>
                <li class="fragment"><img src='images/unittests.jpg'
                width=400px alt='I should start writing unit tests'> </li>
              </ul>

              </section>


          <section class="fragments">
            <h2>Pure functions are more reusable</h2>
            <p></p>
              <ul>
                <li class="fragment">Functional programming encourages functions that are short, simple, and do one thing</li>
                <li class="fragment">Function names become expressive and
                meainingful (e.g. "hasID" or "addsTimeStamp")</li>
                <li class="fragment">Short functions are easier to
                understand</li>
                <li class="fragment">Smaller functions can be reused as part of
                more complex tasks</li>
                <li class="fragment">When higher-level functions are composed
                of smaller functions they become more robust, less
                fragile.</li>
                <li class="fragment"><img src='images/legodino.jpg' width=400px alt='An ounce of prevention is worth a pound of
                cure'></li>
              </ul>
              </section>

          <section class="fragments">
            <h2>Pure functions can be cached</h2>
            <p></p>
              <ul>
                <li class="fragment">When you cache using 'memoization' you get
                better performance</li>
                <li class="fragment">Recursive functions, normally too
                expensive, become viable</li>
              </ul>

              </section>
              <section>
              <pre><code>
var memoize = function(f) {

  //create a cache
  var cache = {};

  return function() {
    var arg_str = JSON.stringify(arguments);

    //If we already have the answer in our cache, do nothing
    //Otherwise, store the result of this function call in our cache
    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);

    return cache[arg_str];
  };
};

function fibonacci(n) {
  return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);
};

function betterFibonacci = memoize(function(n) {
  return (n === 0 || n === 1) ? n : betterFibonacci(n - 1) + betterFibonacci(n - 2);
});

var ITERATIONS = 42;

console.time('non-memoized');
console.log(fibonacci(ITERATIONS));
console.timeEnd('non-memoized'); // 3788ms

console.time('memoized');
console.log(betterFibonacci(ITERATIONS));
console.timeEnd('memoized'); // 1ms !!!
</pre></code>
</section>

              <section>
              <h2>The best part...</h2>
              <ul>
                <li class="fragment">You don't have to completely abandon your
                current practices!</li>
                <li class="fragment">Functional code can live next to Object
                Oriented code</li>
                <li class="fragment">An existing code base can be updated gradually</li>
                <li class="fragment">Learning and using a few patterns of
                functional programming is a great start towards cleaner and
                more elegant code</li>
              </section>

              </section>

              <!-- WHY FP SLIDES/SECTION -->
              <section>
              	<section>
              		<h2>Functional Programming</h2>
              		<h3>The Great Debate</h3>
              		<p>
              			Functional Programming vs. Object Oriented Programming
              		</p>
              		<img src="images/fighting.gif" alt="Everybody was kung-fu fighting">

              		<!-- notes -->
              		<aside class="notes">
              			<small>
              				<ul>
              					<li>Both OOP and FP have the shared goal of creating understandable, flexible programs that are free of bugs.</li>
              					<li>Two primary components: the data (the stuff a program knows) and the behaviors (the stuff a program can do to/with that data).</li>
              					<li>OOP says that bringing together data and its associated behavior in a single location (an Object) makes it easier to understand how a program works.</li>
              					<li>FP says that data and behavior are distinctively different things and should be kept separate for clarity.</li>
              				</ul>
              			</small>
              		</aside>
              	</section>

              	<section>
              		<h2>Functional Programming</h2>
              		<h3>Why FP over OO?</h3>
              		<blockquote> “The problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.”</blockquote>
              		<cite class="text-align-right">-Joe Armstrong</cite>

              		<!-- notes -->
              		<aside class="notes">
              			<small>
              				<ul>
              					<li>For better applications, we need a simple and reliable manner to do it.  In Functional Programming, we’re given those features.  Pure Functions and Immutable State alone give us the ability to run a function a thousand times and still get the same result.</li>
              					<li>Because Object Oriented Programming relies directly on mutable state, the objects methods you call are supposed to mutate the current this.  There’s a lot of complex processes that need to be written just to manage all of the threads in your program to keep them correctly updated and synchronized.  With a functional approach, we don’t need to worry about this.</li>
              					<li>With Functional Programming, functions are broken down to very small methods that are then utilized in first-class and high-order functions that are more complex.  This makes our code not only easier to read as we have pointed out before, it also makes it easier to understand.  Because function names become expressive and meaningful, code becomes more readable and declarative.</li>
              				</ul>
              			</small>
              		</aside>
              	</section>

              </section>
				<!-- LAST SLIDE -->
				<section>

					<section class="">
						<h2>The End</h2>
						<p class="text-align-left">Functional programming is a style that emphasizes and enables the writing of smarter code, which minimizes complexity and increases modularity.</p>
						<img src="images/fp-dino.jpg" alt="fp dino">

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>It's a way of writing cleaner code through clever ways of mutating, combining, and using functions.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section class="fragments">
						<h2>The End</h2>
						<p>JavaScript provides an excellent medium for this approach.</p>
						<img src="images/end-fp.jpg" alt="TMIMITW" style="width: 100%; max-width: 350px;">

						<!-- notes -->
						<aside class="notes">
							<small>
								<ul>
									<li>It's a way of writing cleaner code through clever ways of mutating, combining, and using functions.</li>
									<li>JavaScript is actually a functional language at heart</li>
									<li>By learning how to expose its true identity as a functional language, we can implement web applications that are powerful, easier to maintain, and more reliable</li>
									<li>By doing this, JavaScript's odd quirks and pitfalls will suddenly become clear and the language as a whole will make infinitely more sense.</li>
								</ul>
							</small>
						</aside>
					</section>

					<section>
						<h2>The End</h2>
						<img src="images/gage-x.jpg" alt="Happy Gage - The Buddliest Bud" style="width: 100%; max-width: 350px; position: relative; top: -30px;">
					</section>

					<section>
						<h2>Resources</h2>
						<small>
							<ul>
								<li><a href="https://psdtowp.net/learn-javascript.html" target="_blank">Learn JavaScript: The best methods and resources according to 25 JavaScript experts</a></li>
								<li><a href="https://auth0.com/blog/2016/03/23/intro-to-immutable-js/" target="_blank">Introduction to Immutable.js and Functional Programming Concepts</a></li>
								<li><a href="https://www.gitbook.com/book/drboolean/mostly-adequate-guide/details" target="_blank">Mostly Adequate Guide to Functional Programming</a></li>
								<li><a href="http://eloquentjavascript.net/1st_edition/chapter6.html" target="_blank">Eloquent JavaScript - Functional Programming </a></li>
								<li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4#.hsra264om" target="_blank">The Two Pillars of JavaScript — Pt 2: Functional Programming</a></li>
								<li><a href="https://medium.com/@collardeau/intro-to-functional-programming-concepts-in-javascript-b0650773139c#.plketwxa1" target="_blank">An Intro to Functional Programming Concepts in JavaScript</a></li>
								<li><a href="https://hughfdjackson.com/javascript/why-curry-helps/" target="_blank">Why Curry Helps</a></li>
								<li><a href="http://lucasmreis.github.io/blog/pointfree-javascript/" target="_blank">Point-free JavaScript</a></li>
								<li><a href="http://fr.umio.us/why-ramda/" target="_blank">Why Ramda?</a></li>
								<li><a href="https://medium.com/@jugoncalves/functional-programming-should-be-your-1-priority-for-2015-47dd4641d6b9#.u2649jxjf" target="_blank">Functional Programming should be your #1 priority for 2015</a></li>
								<li><a href="https://github.com/timoxley/functional-javascript-workshop" target="_blank">Functional JavaScript Workshop</a></li>
								<li><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976#.umux9e8mh" target="_blank">Master the JavaScript Interview: What is a Pure Function?</a></li>
								<li><a href="http://curtclifton.net/papers/MoseleyMarks06a.pdf" target="_blank">Reliance on state, the largest contributor to system complexity</a></li>
								<li><a href="http://requiremind.com/memoization-speed-up-your-javascript-performance/" target="_blank">Cacheing Pure Functions and Memoization</a></li>
								<li><a href="https://blog.pivotal.io/labs/labs/all-evidence-points-to-oop-being-bullshit" target="_blank">All evidence points to OOP being bullshit</a></li>
								<li><a href="http://codepen.io/Universalist/post/predicates-in-javascript" target="_blank">Predicates in Javascript</a></li>
								<br>
								<li><a href="https://github.com/hookerz/779-yt-beacon5/tree/lilly-inception-refactor/lilly-inception" target="_blank">Lilly Inception - Refactored</a></li>
							</ul>
						</small>

					</section>

				</section>

			</div> <!-- slides -->

		</div> <!-- reveal -->

		<div id="loadingOverlay">
			<img src="images/logo.png" alt="hook logo">
		</div>


		<script src="js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'js/plugin/zoom-js/zoom.js', async: true },
					{ src: 'js/plugin/notes/notes.js', async: true }
				]
			});

		</script>

		<!-- <script src="js/vendor.js"></script> -->
		<script src="js/main.build.js"></script>

	</body>
</html>
